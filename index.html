<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>fantasyczl</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="fantasyczl">
<meta property="og:url" content="http://fantasyczl.com/index.html">
<meta property="og:site_name" content="fantasyczl">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="fantasyczl">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="fantasyczl" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 4.2.1"></head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">fantasyczl</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">生命是一个过程，生命的精彩在于体验</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://fantasyczl.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-20220405-go-generic-proposal" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/05/20220405-go-generic-proposal/" class="article-date">
  <time datetime="2022-04-05T10:06:04.000Z" itemprop="datePublished">2022-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/04/05/20220405-go-generic-proposal/">Golang 泛型提案学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Go 1.18 支持泛型了。现在抽空就看了一下泛型提案。<a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md" target="_blank" rel="noopener">英文地址</a><br>简单翻译如下：</p>
</blockquote>
<h1 id="翻译名词对照"><a href="#翻译名词对照" class="headerlink" title="翻译名词对照"></a>翻译名词对照</h1><ul>
<li>type =&gt; 类型</li>
<li>constrain =&gt; 结束</li>
<li>interface =&gt; interface</li>
</ul>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>我们建议扩展Go语言，对类型和函数声明添加可选的类型参数。类型参数被 interface 类型约束。当 interface 类型被用作类型限制的时候，可以支持添加额外的元素，用来限制满足 interface 的类型的集合。参数化的类型和函数可能会使用参数的操作，但这种情况只有在所有满足参数约束的类型都允许才行。类型 interface 通过一个统一的算法进行类型推断，以允许在函数调用的时候去掉类型参数。这个设计对 Go1 完全后向兼容。</p>
<h1 id="怎么读这个提案"><a href="#怎么读这个提案" class="headerlink" title="怎么读这个提案"></a>怎么读这个提案</h1><p>这个文章非常长，这是如何阅读的指导：</p>
<ul>
<li>我们从一个高级的概述开始，非常简单的描述概念</li>
<li>然后我们从零开始解释全部的设计，介绍详情，并有简单的例子</li>
<li>在设计全部描述完之后，我们讨论实现，一些设计的问题，然后跟其它的泛型方法比较。</li>
<li>然后我用几个完整的例子，以展示这个实现在实践中是如何使用的。</li>
<li>例子之后，在附录中谈论了一些小的细节。</li>
</ul>
<h1 id="高级别的概述"><a href="#高级别的概述" class="headerlink" title="高级别的概述"></a>高级别的概述</h1><p>这部分非常简要的描述了这个设计建议的修改。这部分是为那些已经熟悉一个语言中, 泛型如何工作的人准备的。这些概念在后面的章节中会有详细的解释。</p>
<ul>
<li>函数可以有一个使用方括号的额外的类型参数列表，但是其它方面像一个普通的参数列表。<code>func F[T any](p T) {...}</code></li>
<li>这些类型参数可以被普通参数使用，也可以在函数体内使用。</li>
<li>类型也可以有类型参数列表：<code>type M[T any] []T</code>.</li>
<li>每个类型参数都有一个类型约束，就像每个普通参数都有一个类型一样：<code>func F[T Constraint](p T) {...}</code></li>
<li>类型约束是 interface 类型。</li>
<li>新的预定义的约束 <code>any</code> 是一个允许所有类型的类型约束。</li>
<li>当 interface 类型作为类型约束的时候，可以另外嵌入元素以限制满足约束的类型集合：<ul>
<li>一个任意的类型 <code>T</code> 限制只能用那个类型。</li>
<li>近似元素 <code>~T</code> 限制只能使用那些底层类型是 T 的类型。</li>
<li>联合元素 <code>T1 | T2 | ...</code> 限制只能使用列出来的类型。</li>
</ul>
</li>
<li>泛型函数使用的操作，必须被所有符合约束的类型都支持。</li>
<li>使用泛型函数或类型，必须传一个类型参数。</li>
<li>在常见情况下，类型推断允许去掉一个函数的类型参数。</li>
</ul>
<p>在接下来的部分中，我们将会对这些语言的修改详细的过一遍，你可能更想跳过开头，到例子部分，看一下实践中的泛型代码是怎么写的。</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在 Go 中，已经有很多要求支持泛型的请求的了。在 issue traker 上也有大量的讨论。</p>
<p>这个设计建议，通过添加一种参数多态的形式，对 Go 语言进行扩展，这里的类型参数不是被声明的子类型关系限制的（就像别的面向对象语言一样），而是被明确定义的结构化约束限制。</p>
<p>这个版本的设计跟2019年7月31号的设计草稿有很多相似的地方，不过 contracts 已经去掉了，替换成了 interface 类型，并且语法也有改变。</p>
<p>针对增加类型参数，已经有几个提案了，可以通过以前的链接找到。这里呈现的很多想法之前也出现过。这里描述的主要新特性是语法和 interface 类型作为约束的仔细检查。</p>
<p>这个设计不支持模板元编程或其它任何形式的编译时编程。</p>
<p>因为术语 <code>generic</code> 在 Go 社区广泛使用，我们下面将使用它来代表一个带着类型参数的函数或类型。不要将本设计中使用的术语 generic 跟其它语言像 C++, C#, Java 或 Rust 中使用的同样的术语搞混淆。它们有相似的地方但是不一样。</p>
<h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><p>我们将分阶段基于例子来描述完整的设计。</p>
<h2 id="类型参数"><a href="#类型参数" class="headerlink" title="类型参数"></a>类型参数</h2><p>泛型代码是使用抽象的数据类型来写的，这种抽象数据类型，我们称作<strong>类型参数</strong>。当运行泛型代码的时候，类型参数将被实际参数替换。</p>
<p>这是一个函数，它输出 slice 中的每个元素，这里 slice 中元素的类型 <code>T</code> 是未知的。这是为了支持泛型编程我们想要允许的函数中，一个微不足道的例子。（稍后我们将讨论泛型类型）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Print 输出 slice 中的元素。</span></span><br><span class="line"><span class="comment">// 它可能被传入任何类型的 slice.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(s []T)</span></span> &#123;  <span class="comment">// 只是一个例子，不是建议的语法</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中，第一个需要做的决定是：类型参数 T 怎么被声明？在像 Go 这样的语言中，我们希望每一个标识符都以某种方式被声明。</p>
<p>这里我做一个设计决定：类型参数跟普通的非类型函数参数相似，并且跟其它参数一起列出来。然而，类型参数跟非类型参数不一样，所以虽然它们都出现在参数列表中，但是我们想要区分它们。这会导致我们下一个设计决定：我们定义一个另外的可选的参数列表来描述类型参数。</p>
<p>类型参数列表出现在普通参数前面。为了区分类型参数列表和普通参数列表，类型参数列表使用方括号而不是小圆括号。就像普通参数拥有类型，类型参数也有元类型，就是约束。我们稍后将讨论约束的细节。现在我们只需要知道 <code>any</code> 是一个有效的约束，意思是任意类型都可以。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Print 输出任意 slice 的元素。</span></span><br><span class="line"><span class="comment">// Print 有一个类型参数 T 和一个单个的普通参数 s, 它是一个 slice, slice的元素类型是 T</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(s []T)</span></span> &#123;</span><br><span class="line">    <span class="comment">// same as above</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是说在 Print 函数中，标识符 T 是一个类型参数，这个类型现在还不知道，但是当函数被调用时就知道了。<code>any</code>的意思是<code>T</code>可以是任何类型。就像上面看到的，当描述普通的非类型参数时，类型参数可以被当作类型使用。在函数体中，它也可以当作类型使用。</p>
<p>跟普通参数列表不一样的是，在类型参数列表中名字是必须的。这可以避免语法歧义，并且没有任何理由去省略类型参数的名字。</p>
<p>由于 Print 有一个类型参数，所有对 Print 的调用必须提供一个类型参数。稍后我们将看到这个类型参数怎么通过非类型参数推断出来。现在我们将明确的传入类型参数。类型参数被传入，就相当于类型参数被声明了：作为一个分享的参数列表。当有类型参数列表时，使用方括号。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 []int 调用 Print.</span></span><br><span class="line"><span class="comment">// Print 有一个类型参数 T，并且我们想传入 []int，</span></span><br><span class="line"><span class="comment">// 所以我们传一个 int 类型参数，这么写 Print[int].</span></span><br><span class="line"><span class="comment">// Print[int] 函数期望参数是 []int</span></span><br><span class="line">Print[<span class="keyword">int</span>]([]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这将会输出</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>让我们的例子稍微复杂点。比如有一个函数，它将为了把一个任意类型的 slice 转换成 []string, 将通过调用每个元素的 String 方法来实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法是非法的。只是演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stringify</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(s []T)</span> <span class="params">(ret []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        ret = <span class="built_in">append</span>(ret, v.String())   <span class="comment">// 非法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一眼看上去好像可以，不过这个例子中 v 的类型是 T, 而 T 可以是任何类型。这意味着 T 不需要有 String 方法。所以 v.String() 的调用是非法的。</p>
<p>当然了，同样的问题在其它支持泛型的语言中也存在。例如在 C++ 中，一个泛型函数（用C++的术语，一个函数模板）可以调用一个泛型类型的值的任意方法。就是在 C++ 中，调用 v.String() 是可以的。如果函数调用使用了一个类型参数，它没有 String 方法，编译的时候会报错。这些报错可能很长，比如在报错发生前有好几层的泛型函数调用时，为了明白哪里出错了，所有这些都需要报出来。</p>
<p>C++ 的方案对 Go 来说是个糟糕的选择。一个原因是语言的风格。在 Go 中我们不引用名字，比如，在这个例子中，String, 并且希望它们存在。当它们被看见的时候，Go 解析所有的名字到它们声明的地方。</p>
<p>另一个原因是 Go 被设计用来支持大规模编程的。我们必须考虑这个例子中泛型函数的定义（上面的 Stringify）以及对泛型函数的调用（没有显示，不过可能在其它包中）相距甚远的情况。一般来讲，所有的泛型代码期望类型参数符合某种确定的要求。我们当这种要求称作<strong>约束</strong>（其它语言有类似的概念，比如类型限制或trait限制或概念）。在这个情况，约束非常明显：类型必须有 <code>String() string</code> 方法。在别的情况中，可能没有那么明显。</p>
<p>我们不想从 Stringify 发生的地方衍生约束（在这个情况中，调用 String 方法的地方）。如果我们做了，对 Stringify 的一个小的改动可能会改变约束。那就意味着一个的改动可能影响很远的代码，调用这个函数的代码意外退出。对 Stringify 故意改变它的约束，并强制调用方改变是没有问题的。我们想要避免的是 Stringify 意外的改变了它的约束。</p>
<p>这意味着约束必须同时在调用者传入的类型参数和泛型函数中的代码中设置限制。调用者只能传满足约束的类型参数。泛型函数只能以约束允许的方式使用这些值。我们相信任何尝试在 Go 中定义泛型编程，这都是一条重要的规则：泛型代码只能使用它的类型参数知道实现了的操作。</p>
<h2 id="任意类型允许的操作"><a href="#任意类型允许的操作" class="headerlink" title="任意类型允许的操作"></a>任意类型允许的操作</h2><p>在我们讨论约束之前，我们简单的记住 <code>any</code> 约束是什么。如果一个泛型函数使用 <code>any</code> 约束，就像上面的 Print 函数一样，任意类型都允许。泛型函数中类型参数的值可以使用的操作就是那些被任意类型都允许的操作。在上面的例子中，Print 函数声明了一个变量 v 它的类型是 T，并且它把这个变量传给函数。</p>
<p>任意类型允许的操作是：</p>
<ul>
<li>声明这些类型的变量</li>
<li>把同类型的其它值你分配给这些值</li>
<li>把这些变量传给函数或者在函数返回它们</li>
<li>取这些变量的地址</li>
<li>转换或者分配这些类型的值给 interface{}</li>
<li>转换 T 类型的值到类型 T （允许但是没有用）</li>
<li>使用类型断言把一个 interace 类型的值转到这些类型</li>
<li>用在 type switch 中的 case</li>
<li>定义和使用这些类型的组合类型，比如这些类型的 slice</li>
<li>把这些类型传一些预定义的函数，比如 <code>new</code></li>
</ul>
<p>可能随着未来语言变化，可能增加其它的操作，但这不是现在可以预料的。</p>
<h3 id="定义约束"><a href="#定义约束" class="headerlink" title="定义约束"></a>定义约束</h3><p>Go 中已经有一种合约非常接近我们<strong>约束</strong>的需要：interface 类型。一个 interface 类型是一组方法。只有那些类型实现了同样的方法，它们的值才能分配给 interface 类型的值。interface 类型的值可以的事情，不是类型允许的操作，只是调用这些方法。</p>
<p>使用类型参数调用一个泛型函数跟赋值给 interface 类型非常相似：传入的类型参数必须实现类型参数的约束。写一个泛型函数就像使用 interface 类型的值：泛型代码只能使用被约束允许的操作（或者被<code>any</code> 类型允许的操作）。</p>
<p>所以，在这个设计中，约束就是简单的 interface 类型。满足约束就意味着实现 interface 类型。（为了定义非方法的操作约束，比如二进制操作，后面我们再重述这个）。</p>
<p>对于 Stringify 例子，我们需要一个 interface 类型：它有一个 String 方法，没有入参，返回一个 String 的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stringer 是一个类型约束，它要求类型参数有一个 String 方法并允许泛型函数调用 String.</span></span><br><span class="line"><span class="comment">// String 方法应该返回一个 string 代表的值。</span></span><br><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（跟这个讨论来没关系，但是这里定义了跟标准库 <code>fmt.Stringer</code> 一样的 interface 类型，真实的代码应该直接使用 <code>fmt.Stringer</code>）。</p>
<h2 id="any-约束"><a href="#any-约束" class="headerlink" title="any 约束"></a>any 约束</h2><p>现在我们知道约束就是简单的 interface 类型，我们可以解释 any 约束是什么意思。就像上面显示的那样，any 约束允许任何类型作为类型参数，并且只允许函数使用任意类型允许的操作。它的 interface 类型就是 <code>interface{}</code> （空接口）。所以我们像这样写 Print 的例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span>[<span class="title">T</span> <span class="title">interface</span></span>&#123;&#125;](s []T) &#123;</span><br><span class="line">    <span class="comment">// 跟上面一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，每次当你要写一个泛型函数，它不强制类型参数的约束的时候，必须每次都写 <code>interface{}</code>，这太无聊了。所以在这个设计中，我们建议约束 <code>any</code> 等价于 <code>interface{}</code>。这将是一个预定义的名字，在 universe block 中隐式声明。使用 any 用作类型参数约束以外的地方是无效的。</p>
<p>（注意：显然我们可以将 any 作为 interface{} 的别名，或者作为定义为 interface{} 的新类型。但是我们不希望这种关于泛型的设计导致非泛型代码的重大修改。添加 any 作为 interface{} 的通用名称可以而且应该单独讨论）</p>
<h2 id="使用约束"><a href="#使用约束" class="headerlink" title="使用约束"></a>使用约束</h2><p>对于泛型函数，约束中可以认为是类型参数的类型：元类型。就像上面显示的那样，约束出现在类型参数列表中，作为类型参数的元类型。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stringify 调用 s 中每个元素的 String 方法， 并且返回结果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stringify</span>[<span class="title">T</span> <span class="title">Stringer</span>]<span class="params">(s []T)</span> <span class="params">(ret []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        ret = <span class="built_in">append</span>(ret, v.String())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个情形中，类型参数 T 后面跟着对它的约束。</p>
<h2 id="多个类型参数"><a href="#多个类型参数" class="headerlink" title="多个类型参数"></a>多个类型参数</h2><p>虽然 Stringify 的例子只用了一个类型参数，函数也可以有多个类型参数。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Print2 有两个类型参数，和两个非类型参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print2</span>[<span class="title">T1</span>, <span class="title">T2</span> <span class="title">any</span>]<span class="params">(s1 []T1, s2 []T2)</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><br>跟这个相比<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Print2Same 有一个类型参数和两个非类型参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print2Same</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(s1 []T, s2 []T)</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p>Print2 中，s1 和 s2 可能是不同类型的 slice。在 Print2Same 中，s1 和 s2 必须是同一个类型的 slice。</p>
<p>就像每个普通参数都有自己的类型，每个类型参数也有自己的约束。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stringer 是一个需要 String 方法的约束。</span></span><br><span class="line"><span class="comment">// String 方法需要返回一个 string。</span></span><br><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Plusser 是一个需要 Plus 方法的约束。</span></span><br><span class="line"><span class="comment">// Plus 方法期望对内部的字符串增加一个参数，然后返回结果。</span></span><br><span class="line"><span class="keyword">type</span> Plusser <span class="keyword">interface</span> &#123;</span><br><span class="line">    Plus(<span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcatTo 接收一个slice, 其中每个元素都有一个 String 方法，和一个slice, 其中每个元素都有一个 Plus 方法。</span></span><br><span class="line"><span class="comment">// 这些 slice 的元素数量比須相同。这将把 s 中的每个元素转成一个字符串，把它传给 p 中相应元素的 Plus 方法，</span></span><br><span class="line"><span class="comment">// 并且返回一个 slice, 其中包含结果 string.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcatTo</span>[<span class="title">S</span> <span class="title">Stringer</span>, <span class="title">P</span> <span class="title">Plusser</span>]<span class="params">(s []S, p []P)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    r := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(s))</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        r[i] = p[i].Plus(v.String())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个约束可以用到多个类型参数，就像一个类型参数可以用到多个非类型参数上。约束单独应用到每个类型参数上。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stringify2 将两个不类型的 slice 转成 string, 并且返回所有 string 连接的结果。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stringify2</span>[<span class="title">T1</span>, <span class="title">T2</span> <span class="title">Stringer</span>]<span class="params">(s1 []T1, s2 []T2)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    r := <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> _, v1 := <span class="keyword">range</span> s1 &#123;</span><br><span class="line">        r += v1.String()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, v2 := <span class="keyword">range</span> s2 &#123;</span><br><span class="line">        r += v2.String()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h2><p>除了泛型函数，我们还想要泛型类型。我们建议类型可以被扩展到接受类型参数。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vector 是一个元素可以为任意类型的 slice.</span></span><br><span class="line"><span class="keyword">type</span> Vector[T any] []T</span><br></pre></td></tr></table></figure></p>
<p>类型的类型参数就像函数的类型参数一样。</p>
<p>在类型定义中，类型参数可以像别的类型一样使用。</p>
<p>为了使用泛型类型，你必须提供类型参数。这叫做实例化。类型参数就像以前一样出现在方括号中。当我们通过为类型参数提供类型参数来实例化一个类型时，我们会产生一个类型，其中在类型定义中的类型参数的每次使用，都会被相应类型实参替换。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v 是一个整形值的 Vector</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 这就相当于假装 "Vector[int]" 是一个有效的标识符，</span></span><br><span class="line"><span class="comment">// 并且写做</span></span><br><span class="line"><span class="comment">//      type "Vector[int]" []int</span></span><br><span class="line"><span class="comment">//      var v "Vector[int]"</span></span><br><span class="line"><span class="comment">// 所有 Vector[int] 使用的地方都指向同一个 "Vector[int]" type.</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">var</span> v Vector[<span class="keyword">int</span>]</span><br></pre></td></tr></table></figure>
<p>泛型类型也可以有方法。方法的接收者类型必须声明同样数量的类型参数, 跟声明在接收者类型定义一样。它们的声明没有约束。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Push 增加一个值到一个 Vector 的末尾</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vector[T])</span> <span class="title">Push</span><span class="params">(x T)</span></span> &#123; *v = <span class="built_in">append</span>(*v, x) &#125;</span><br></pre></td></tr></table></figure>
<p>在方法声明中列出的类型参数，不需要拥有跟在类型定义中的类型参数一样的名字。特别地，如果它们没有被方法使用，它们可以是 <code>_</code>。</p>
<p>在一个类型通常可以引用自身的情况下，泛型类型可以引用自身。但是当它这样做时，类型参数必须是类型参数，以相同的顺序列出。此限制可以防止类型参数实例化的无限递归。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List 是一个链表，其值是类型 T</span></span><br><span class="line"><span class="keyword">type</span> List[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    next *List[T]  <span class="comment">// 这个引用到 List[T] 是允许的</span></span><br><span class="line">    val T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个类型是无效的</span></span><br><span class="line"><span class="keyword">type</span> P[T1, T2 any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    F *P[T2, T1] <span class="comment">// 无效的； 必须是 [T1, T2]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个限制对直接引用和间接引用都有效。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListHead 是一个链表的头</span></span><br><span class="line"><span class="keyword">type</span> ListHead[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    head *ListElement[T]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListElement 是有头链表的一个元素。</span></span><br><span class="line"><span class="comment">// 每个元素指向头</span></span><br><span class="line"><span class="keyword">type</span> ListElement[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    next *ListElement[T]</span><br><span class="line">    val T</span><br><span class="line">    <span class="comment">// 这里使用 ListHead[T] 是可以的。</span></span><br><span class="line">    <span class="comment">// ListHead[T] 引用 ListElement[T] 引用 ListHead[T]。</span></span><br><span class="line">    <span class="comment">// 使用 ListHead[int] 就不可以，因为 ListHead[T] 可能有一个间接引用到 ListHead[int].</span></span><br><span class="line">    head *ListHead[T]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(注意：随着对人首怎么写代码越来越了解，可能会放松这个规则以允许一些使用不同类型参数的case)</p>
<p>泛型类型的类型参数可能拥有不是any 的约束。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StringableVector 是一个一些类型的 slice，这里的类型必须有 String 方法。</span></span><br><span class="line"><span class="keyword">type</span> StringableVector[T Stringer] []T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StringableVector[T])</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sb strings.Builder</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">            sb.WriteString(<span class="string">", "</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里调用 v.String() 是可以的，因为 v 的类型是 T，T有一个约束是 Stringer</span></span><br><span class="line">        sb.WriteString(v.String())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法可能不带另外的类型参数"><a href="#方法可能不带另外的类型参数" class="headerlink" title="方法可能不带另外的类型参数"></a>方法可能不带另外的类型参数</h2><p>尽管泛型类型的方法可能使用类型参数，方法可能没有另外的类型参数。这里给方法增加类型参数可能是有用的，人们不得不写一个适当参数化的顶级函数。</p>
<p><a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#No-parameterized-methods" target="_blank" rel="noopener">这里有更多的讨论</a></p>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>就像我们看到的，我们使用 interface 类型数作约束。interface 类型除了提供了一个方法集，没有提供别的。这意味着迄今为止我们看到的，泛型函数可以做的唯一事情就是使用类型参数的值，除了任何类型允许的操作外，就是调用方法。</p>
<p>然而，方法调用不能满足我们想表达的所有。思考这个简单的函数：它返回slice 中最小的元素，假定slice不为空。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数是无效的。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Samllest</span>[<span class="title">T</span> <span class="title">any</span>] <span class="params">(s []T)</span></span> &#123;</span><br><span class="line">    r := s[<span class="number">0</span>]    <span class="comment">// 如果 slice 为空就会panic</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s[<span class="number">1</span>:] &#123;</span><br><span class="line">        <span class="keyword">if</span> v &lt; r &#123;  <span class="comment">/// 无效的</span></span><br><span class="line">            r = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何合理的泛型实现都该允许你编写这样的函数。问题是表达式 <code>v &lt; r</code>。这假定<code>T</code>支持<code>&lt;</code>操作符，<code>T</code>上的约束是<code>any</code>。拥有<code>any</code>约束的函数<code>Smallest</code>只能使用所有类型都允许的操作，但是不是所有类型都支持<code>&lt;</code>。不幸地，因为<code>&lt;</code>不是一个方法，所以没有一个明显的方法来写一个约束 —- 一个interface 类型 —- 让它允许使用<code>&lt;</code>。</p>
<p>我们需要一种方法来写一个约束，让它只接受支持<code>&lt;</code>的类型。为了做到这个，我们观察，除了后面将这个请求的两个例外，语言定义的所有的算术运算，比较，和逻辑运算符可能只能用到语言预定义的类型上，或者是定义的类型，但是它的底层类型是预定义类型。那就是<code>&lt;</code>操作符只能被用在预定义的类型像<code>int</code>或者<code>float64</code>，或者定义的类型它的底层是这些类型。Go不允许组合类型或任意自定义类型使用<code>&lt;</code>。</p>
<p>这意味着与其尝试编写<code>&lt;</code>的约束，我们可以反过来处理：与其说一个约束应该支持哪些运算符，我们可以说一个约束应该接受哪些类型。我们通过为约束定义一个类型集来做到这一点。</p>
<h3 id="类型集"><a href="#类型集" class="headerlink" title="类型集"></a>类型集</h3><p>虽然我们的主要兴趣在于定义约束的类型集合，最直观的方法就是定义所有类型的集合。约束的类型集就从这些集合中挑。这似乎与将运算符与参数化类型一起使用的主题偏离了主题，但我们最终会到达那里。</p>
<p>每一个类型有相关的类型集。一个非接口类型 T 的类型集只是简单的集合<code>{T}</code>：一个只包含 T 的集合。一个普通接口类型的类型集就是所有声明了接口中方法的类型的集合。</p>
<p>注意普通接口类型的类型集是一个无限集合。对于任何给定的类型 T 和一个接口类型 IT 非常容易判断 T 是否在类型集 IT 中（通过判断 T 是否声明了 IT 所有的方法），但是没有合理的方法去枚举 IT 类型集中所有的类型。IT 是它自己的类型集中的一员，因为一个接口内存地声明了它自己所有的方法。空接口的类型集<code>interface{}</code>是所有类型的集合。</p>
<p>通过检查接口中的元素，对于构建接口类型的类型集合，将会很有用。这跟另一个不同的方式将产生同样的结果。接口的元素可以是方法签名或嵌入式接口类型。虽然一个方法签名不是一个类型，但是它定义一个类型集很方便：所有声明了那个方法的类型集合。一个嵌入式的接口类型 E 的类型集就是 E: 所有声明了 E 中所有方法的类型集合。</p>
<p>对于任意方法签名 M，<code>interface{ M }</code>的类型集是 M 的类型：所有声明 M 的类型的集合。对于任意方法签名 M1 和 M2，<code>interface{ M1; M2}</code>的类型集合就是所有同时声明了 M1 和 M2 的类型的集合。这是 M1 类型集和 M2 的类型集的交集。观察这个发现，M1 的类型集就是所有拥有方法 M1 的类型，M2 也类似。如果我们取它们的交集，结果就是同时声明了 M1 和 M2 的类型集。那就是确实的 <code>interface{ M1; M2}</code>的类型集。</p>
<p>这同样可以应用到嵌入式接口类型。对于任何两个接口类型 E1 和 E2，<code>interface{ E1; E2}</code>的类型集就是 E1 和 E2 的类型集的交集。</p>
<p>所以，一个接口类型的类型集就是接口元素的类型集的交集。</p>
<h3 id="约束的类型集"><a href="#约束的类型集" class="headerlink" title="约束的类型集"></a>约束的类型集</h3><p>现在我们描述了接口类型的类型集，我们将重新定义<strong>满足约束</strong>的意思。前面我们说过一个类型参数满足一个约束就是它实现了约束。现在我们将说一个类型参数满足约束就是它是约束的类型集的一员。</p>
<p>对于一个普通的接口类型，它的唯一元素就是方法签名和嵌入式普通接口类型，这意味着：实现接口的类型集正是其类型集中的类型集。</p>
<p>我们现在将继续定义那可能出现在接口类型中用于约束时的元素，并且定义这些额外的元素用作约束时，怎么控制约束的类型集。</p>
<h3 id="约束元素"><a href="#约束元素" class="headerlink" title="约束元素"></a>约束元素</h3><p>普通接口类型的元素是方法签名和嵌入式接口类型。我们建议当接口类型用作约束时，允许三个额外的元素。如果这三个元素被使用了，这个接口类型不能被用作普通的类型，但只可以用作约束。</p>
<h4 id="任意类型约束元素"><a href="#任意类型约束元素" class="headerlink" title="任意类型约束元素"></a>任意类型约束元素</h4><p>第一个新元素是允许列出任意类型，不只是接口类型。例如：整数类型<code>type Integer interface{ int }</code>。当一个非接口类型 T 被列出来当作一个约束的元素时，它的类型集就是<code>{T}</code>。int 的类型集就是<code>{int}``。因为约束的类型集是所有元素的类型集的交集，Integer 的类型集是</code>{int}<code>。这个约束 Integer 可以被任何</code>{int}<code>`</code>中的一员满足。有一个确切的类型：int。</p>
<p>类型可以是引用类型参数（或更多）的类型文字，不过它不能是普通的类型参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EmbeddedParameter is 是非法的。</span></span><br><span class="line"><span class="keyword">type</span> EmbeddedParameter[T any] <span class="keyword">interface</span> &#123;</span><br><span class="line">	T <span class="comment">// 非法的： 不能列出一个普通的类型参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="近似约束元素"><a href="#近似约束元素" class="headerlink" title="近似约束元素"></a>近似约束元素</h4><p>列出一个单个类型本身是没有用的。对于约束满足，我们想要说不只是 int，还包括 “底层类型是int 的所有类型”。思考一下上面的 Smallest 的例子。我们想要它不只对预定义的顺序类型的slice 有效，也要对程序定义的类型有效。如果一个程序使用<code>type MyString string</code>，程序就可以对 MyString 使用<code>&lt;</code>操作符。可以使用类型 MyString 来实例化 Smallest。</p>
<p>为了支持这个，我们提议的在约束中使用的第二个新元素是一个新语法构造：近似元素，写做<code>~T</code>。~T 的类型集就是所有底层类型是 T 的所有类型的集合。</p>
<p>例如：<code>type AnyString interface{ ~string }</code>。~string 的类型集，因此AnyString的类型集，是底层类型是 string 的所有类型的集合。这包含了 MyString；MyString 用作类型参数将满足约束 AnyString。</p>
<p>这个新的 ~T 的语法将是在 Go 中第一个使用 ~ 符号的。</p>
<p>因为 ~T 意味着所有底层类型是 T 的类型集合，因此如果 T 的底层类型不是它自己，将 ~  与 T 一起使用将是错误的。其底层类型是本身的类型是：</p>
<ul>
<li>类型文字，比如 []byte 或者 struct{ f int }。</li>
<li>大多数的预定义类型，比如 int 或 string （error不是）。</li>
<li>如果 T 是类型参数或者 T 是一个接口类型， ~T 是不允许被使用的。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyString <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AnyString 匹配任何底层类型是 string 的类型。</span></span><br><span class="line"><span class="comment">// 这包括 string 类型自己和 MyString</span></span><br><span class="line"><span class="keyword">type</span> AnyString <span class="keyword">interface</span> &#123;</span><br><span class="line">	~<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ApproximateMyString 是无效的</span></span><br><span class="line"><span class="keyword">type</span> ApproximateMyString <span class="keyword">interface</span> &#123;</span><br><span class="line">	~MyString <span class="comment">// 无效的：MyString的类型不是MyString</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ApproximateParameter 是无效的</span></span><br><span class="line"><span class="keyword">type</span> ApproximateParameter[T any] <span class="keyword">interface</span> &#123;</span><br><span class="line">	~T <span class="comment">// 无效：T是类型参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="联合约束元素"><a href="#联合约束元素" class="headerlink" title="联合约束元素"></a>联合约束元素</h4><p>在约束中我们提议增加的第三个新元素也是一个新语法构造：一个联合元素，写作一系列约束元素被竖线分隔。例如：<code>int | float32</code> 或者<code>~int8 | ~int16 | ~int32 | ~int64</code>。一个联合元素的类型集合是序列中每个元素的类型集合的并集。列在并集中的元素必须不同。比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PredeclaredSignedInteger 是一个匹配五个预定义的有符号整数的约束</span></span><br><span class="line"><span class="keyword">type</span> PredeclaredSignedInteger <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="keyword">int</span> | <span class="keyword">int8</span> | <span class="keyword">int16</span> | <span class="keyword">int32</span> | <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>联合元素的类型集合是<code>{int, int8, int16, int32, int64}</code>。由于联合是 PredeclaredSignedInteger 中的唯一元素，这也是 PredeclaredSignedInteger 的类型集。这个约束可以被这五个类型的任意一个满足。</p>
<p>这是一个使用近似元素的例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SignedInteger 是一个匹配任意有符号整数的约束。</span></span><br><span class="line"><span class="keyword">type</span> SignedInteger <span class="keyword">interface</span> &#123;</span><br><span class="line">	~<span class="keyword">int</span> | ~<span class="keyword">int8</span> | ~<span class="keyword">int16</span> | ~<span class="keyword">int32</span> | ~<span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个约束的类型集是所有底层类型是 int, int8, int16, int32, 或者int64 其中一个的类型集合。这些类型将满足这个约束。</p>
<p>新约束元素的语法是</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InterfaceType  = <span class="string">"interface"</span> <span class="string">"&#123;"</span> &#123;(MethodSpec | InterfaceTypeName | ConstraintElem) <span class="string">";"</span> &#125; <span class="string">"&#125;"</span> .</span><br><span class="line">ConstraintElem = ConstraintTerm &#123; <span class="string">"|"</span> ConstraintTerm &#125; .</span><br><span class="line">ConstraintTerm = [<span class="string">"~"</span>] Type .</span><br></pre></td></tr></table></figure>
<h3 id="基于类型集的操作"><a href="#基于类型集的操作" class="headerlink" title="基于类型集的操作"></a>基于类型集的操作</h3><p>类型集合的目的是允许泛型函数使用操作符，比如：&lt;，与类型是类型参数的值一起使用。</p>
<p>无则是泛型函数可能使用一个值，它的类型是一个类型参数以某种方式被类型参数的约束的类型集中的每个成员都允许的。这应用到像‘&lt;’ 或 ‘+’ 或者其它泛型操作符。对于特殊目的的操作符，像range循环，如果类型参数有一个 structural 约束，我们也允许使用。这里的约束定义是基本的，只有一个单个的底层类型。如果函数使用约束的类型集中的每个类型都能编译通过，或者当使用 structural 类型应用，然后使用是允许的。</p>
<p>对于之前的 Smallest 例子，我们像这样使用约束：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> constraints</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ordered 是一个类型约束，匹配任意的顺序类型。</span></span><br><span class="line"><span class="comment">// 一个顺序类型是支持像 &lt;, &lt;=, &gt;, 和 &gt;= 的操作符。</span></span><br><span class="line"><span class="keyword">type</span> Ordered <span class="keyword">interface</span> &#123;</span><br><span class="line">	~<span class="keyword">int</span> | ~<span class="keyword">int8</span> | ~<span class="keyword">int16</span> | ~<span class="keyword">int32</span> | ~<span class="keyword">int64</span> |</span><br><span class="line">		~<span class="keyword">uint</span> | ~<span class="keyword">uint8</span> | ~<span class="keyword">uint16</span> | ~<span class="keyword">uint32</span> | ~<span class="keyword">uint64</span> | ~<span class="keyword">uintptr</span> |</span><br><span class="line">		~<span class="keyword">float32</span> | ~<span class="keyword">float64</span> |</span><br><span class="line">		~<span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实践中，这个约束将会在一个新的标准库包中被定义并且可导出，constraints，所以这可以被函数和类型定义使用。</p>
<p>给定 constraint，我们可以这样写这个函数，现在是合法的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Smallest 返回 slice 中最小的元素</span></span><br><span class="line"><span class="comment">// 如果 slice 是空，它会panic</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Smallest</span>[<span class="title">T</span> <span class="title">constraints</span>.<span class="title">Ordered</span>]<span class="params">(s []T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">	r := s[<span class="number">0</span>] <span class="comment">// 如果为空会panic</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s[<span class="number">1</span>:] &#123;</span><br><span class="line">		<span class="keyword">if</span> v &lt; r &#123;</span><br><span class="line">			r = v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="约束中的可比较类型"><a href="#约束中的可比较类型" class="headerlink" title="约束中的可比较类型"></a>约束中的可比较类型</h3><p>之前我们提到过，对于操作符只可以被语言预定义的类型使用的规则，有两个例外。这两个例外是 == 和 !=，它们也可以用到 struct, array, interface 上。这对于我们想要写一个接受任何可比较类型的约束，已经够用了。</p>
<p>为了做到这个，我们介绍一个新的预定义的约束：comparable。comparable 约束的类型集是所有可比较类型的集合。这个类型参数允许使用 == 和 != 。</p>
<p>例如：这个函数可以使用任何可比较类型实例化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Index 返回 x 在 s 中的索引，如果不存在就返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span>[<span class="title">T</span> <span class="title">comparable</span>]<span class="params">(s []T, x T)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		<span class="comment">// v 和 x 是 T 类型，是可比较的约束，所以我们可以使用 ==</span></span><br><span class="line">		<span class="keyword">if</span> v == x &#123;</span><br><span class="line">			<span class="keyword">return</span> i</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 comparable 是约束，它可以作为约束嵌入到别的接口类型中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ComparableHasher 是一个匹配所有可比较类型且有一个 Hash 方法的约束。</span></span><br><span class="line"><span class="keyword">type</span> ComparableHasher <span class="keyword">interface</span> &#123;</span><br><span class="line">	comparable</span><br><span class="line">	Hash() <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>约束 ComparableHasher 可以被任何一个是可比较的且有一个 Hash() uintptr 方法的类型实现。一个使用 ComparableHasher 作为约束的泛型函数，可以比较类型的值，也可以调用 Hash 方法。</p>
<p>可以使用可比较来产生任何类型都无法满足的约束。另请参阅下面对空类型集的讨论。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ImpossibleConstraint 是一个没有类型可以满足的约束，</span></span><br><span class="line"><span class="comment">// 因为 slice 类型是不可比较的。</span></span><br><span class="line"><span class="keyword">type</span> ImpossibleConstraint <span class="keyword">interface</span> &#123;</span><br><span class="line">	comparable</span><br><span class="line">	[]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="互相引用的类型参数"><a href="#互相引用的类型参数" class="headerlink" title="互相引用的类型参数"></a>互相引用的类型参数</h2><p>在一个单类型参数列表中，约束可以引用另外的类型参数，甚至它定义在同一个列表的后面也可以。（类型参数的范围在类型参数列表的开头开始，一直延伸到类型封装函数或声明的末尾）</p>
<p>例如，思考一个泛型的图形包，它包含关于图形的泛型算法。算法使用两个类型，Node 和 Edge。Node 有一个方法<code>Edges() []Edge</code>。Edge 有一个方法<code>Nodes() (Node, Node)</code>。一个图形可以表示为 []Node。</p>
<p>这个简单的表示足够实现像寻找最短路径的图形算法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> graph</span><br><span class="line"></span><br><span class="line"><span class="comment">// NodeConstraint 是一个对于图形 Nodes 的类型约束：</span></span><br><span class="line"><span class="comment">// 它们必须有一个 Edges 方法，返回连接到这个 Node 的 Edges。</span></span><br><span class="line"><span class="keyword">type</span> NodeConstraint[Edge any] <span class="keyword">interface</span> &#123;</span><br><span class="line">	Edges() []Edge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EdgeConstraint 是一个对于 edges 的类型约束：</span></span><br><span class="line"><span class="comment">// 他们必须有一个 Nodes 方法，返回这个 Edge 连接的两个 Node。</span></span><br><span class="line"><span class="keyword">type</span> EdgeConstraint[Node any] <span class="keyword">interface</span> &#123;</span><br><span class="line">	Nodes() (from, to Node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Graph 是一个由 nodes 和 edges 组成的图形。</span></span><br><span class="line"><span class="keyword">type</span> Graph[Node NodeConstraint[Edge], Edge EdgeConstraint[Node]] <span class="keyword">struct</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New 给定一系列 nodes, 返回一个新图形。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span>[<span class="title">Node</span> <span class="title">NodeConstraint</span>[<span class="title">Edge</span>], <span class="title">Edge</span> <span class="title">EdgeConstraint</span>[<span class="title">Node</span>]] <span class="params">(nodes []Node)</span> *<span class="title">Graph</span>[<span class="title">Node</span>, <span class="title">Edge</span>]</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ShortestPath 返回两个 nodes 间最短的路径，由一系列 edges 组成。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Graph[Node, Edge])</span> <span class="title">ShortestPath</span><span class="params">(from, to Node)</span> []<span class="title">Edge</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>这里有很多类型参数和实例。在图形 Node 的约束中，传给类型约束 NodeConstraint 的 Edge，是图形的第二个类型参数。这样使用类型参数 Edge 实例化 NodeConstraint，我们看到 Node 必须有一个Edges方法，它返回 Edge 的 slice，这就是我们要的。同样应用到 Edge 的约束，同样的类型参数和约束在 New 函数重复了一次。我们不是想说明这样很简单，只是说明这样是可能的。</p>
<p>修复注意的是，乍一看这可能看起来像是接口类型的典型用法，Node 和 Edge 是拥有特殊方法的非接口类型。为了使用 graph.Graph，用于 Node 和 Edge 的类型参数必须定义遵循特定模式的方法，但是它们不能使用接口类型来这样做。特别是，方法不是返回接口类型。</p>
<p>例如，思考在别的包里的类型定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vertex 是一个图形的 Node</span></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Edges 返回边到 v 上的 edges</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Edges</span><span class="params">()</span> []*<span class="title">FromTo</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FromTo 图形中的一条边</span></span><br><span class="line"><span class="keyword">type</span> FromTo <span class="keyword">struct</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Nodes 返回 ft 连接的 nodes </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ft *FromTo)</span> <span class="title">Nodes</span><span class="params">()</span> <span class="params">(*Vertex, *Vertex)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>这里没有接口类型，介理我们使用<code>*Vertex</code>和<code>*FromTo</code>来实例化<code>graph.Graph</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = graph.New[*Vertex, *FromTo]([]*Vertex&#123; ... &#125;)</span><br></pre></td></tr></table></figure>
<p>*Vertex 和 *FromTo 不是接口类型，但是当一起使用的时候，它们定义的方法实现了 graph.Graph 的约束。iyuj我们不能直接把 Vertex 或 FromTo 传给 graph.New，因为 Vertext 和 FromTo 没有实现约束。Edges 和 Nodes 方法是定义在指针类型 *Vertex 和 *FromTo；类型 Vertex 和 FromTo 没有任何方法。</p>
<p>当我们使用一个泛型接口类型作为约束时，我们第一个实例化的类型，是在类型参数列表中提供了类型参数，然后比较相应的类型参数与实例化的约束。在这个例子中，graph.New 的 Node 类型参数有一个约束 NodeConstraint[Edge]。当我们使用 Node 类型参数 *Vertex 和 Edge 类型参数 *FromTo 来调用 graph.New 的时候，为了检查 Node 上的约束，编译器使用类型参数 *FromTo 实例化 NodeConstraint。这产生一个实例化的约束，在这个情况下，需要 Node 有一个方法<code>Edges() []*FromTo</code>，并且编译器验证 *Vertex 满足这个约束。</p>
<p>虽然 Node 和 Edge 不是必须使用接口类型来实例化，如果你喜欢，使用接口类型也可以。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NodeInterface <span class="keyword">interface</span> &#123; Edges() []EdgeInterface &#125;</span><br><span class="line"><span class="keyword">type</span> EdgeInterface <span class="keyword">interface</span> &#123; Nodes() (NodeInterface, NodeInterface) &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以使用 NodeInterface 和 EdgeInterface 来实例化 graph.Graph，因为它们实现了类型约束。没有足够的理由来这么实例化，但是这是允许的。</p>
<p>这种类型参数引用另一个类型参数的能力说明了一个重要的点：任何在 Go 中增加泛型的尝试，都应该要求能够实例化具有多个类型参数的泛型代码，这些类型参数以编译器可以检查的方式相互引用。</p>
<h2 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h2><p>在许多情况下，我们可以使用类型推断来避免明确的写一些或全部的类型参数。我们可以使用函数参数类型推断，对于函数调用从非类型参数的类型推断类型参数。我们可以使用约束类型推断，从已知类型参数来推断未知类型参数。</p>
<p>在上面的例子中，当实例化一下泛型函数或者类型时，我们总是为所有的类型参数都指定参数。我们也允许只指定一部分类型参数，或者当没有类型参数可以被推断出来时，完全去掉类型参数，它们是列表中的第一个类型参数的入参。</p>
<p>例如，一个函数像这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Map</span>[<span class="title">F</span>, <span class="title">T</span> <span class="title">any</span>]<span class="params">(s []F, f <span class="keyword">func</span>(F)</span> <span class="title">T</span>) []<span class="title">T</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>可以被以三种方式调用。（我们下面将解释类型推断工作的细节；这个例子只是展示类型参数处理的不完全列表）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int64</span></span> &#123; <span class="keyword">return</span> <span class="keyword">int64</span>(i) &#125;</span><br><span class="line"><span class="keyword">var</span> r []<span class="keyword">int64</span></span><br><span class="line"><span class="comment">// 所有的类型参数都明确。</span></span><br><span class="line">r = Map[<span class="keyword">int</span>, <span class="keyword">int64</span>](s, f)</span><br><span class="line"><span class="comment">// 只指定第一个类型参数，F，让T被推断出来。</span></span><br><span class="line">r = Map[<span class="keyword">int</span>](s, f)</span><br><span class="line"><span class="comment">// 不批审任何类型参数，让它们都被推断出来。</span></span><br><span class="line">r = Map(s, f)</span><br></pre></td></tr></table></figure>
<p>如果一个泛型函数或类型使用的时候没有指定所有的类型参数，如果未指定的参数不能被推断出来，就会报错。</p>
<p>（注意：类型推断是一个很方便的特性。虽然我们认为它是一个重要的特性，它不添加任何功能到设计中，只是使用上方便。从初始实现中去掉是完全可能的，然后看一下它是否需要。这就是说，这个特性不需要另外增加语法，就可以增加更多的可读性。）</p>
<h3 id="类型统一"><a href="#类型统一" class="headerlink" title="类型统一"></a>类型统一</h3><p>类型推断是基于类型统一的。类型统一应用到两个类型，它们中的一个或全部可能是或包含类型参数。</p>
<p>类型统一通过比较类型的结构来生效。它们的结构不考虑类型参数必须相同，并且类型参数以外的类型必须等价。一种类型的类型参数可能匹配任何一个另一种类型的子类型。如果结构不同，或者类型参数之外的类型不等价，那么类型统一就会失败。成功的类型统一提供了类型参数与其它类型（它们本身可能是或包含类型参数）的关联列表。</p>
<p>对于类型统一，如果两个不包含任何类型参数的类型相同，或者它们是相同的忽略通道方向的通道类型，或者底层类型相同，则它们是等价的。在类型推断期间允许类型不相同是可以的，因为如果推断成功，我们仍将检查约束，并且我们仍将检查函数参数是否可分配给推断的类型。</p>
<p>例如，如果 T1 和 T2 是类型参数，[]map[int]bool 可以被统一成以下任一形式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[]<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span></span><br><span class="line">T1 (T1 matches []<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line">[]T1 (T1 matches <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line">[]<span class="keyword">map</span>[T1]T2 (T1 matches <span class="keyword">int</span>, T2 matches <span class="keyword">bool</span>)</span><br></pre></td></tr></table></figure>
<p>（这不是一个专有列表，也有其它可能成功的统一形式。）</p>
<p>另一方面，[]map[int]bool 不能被统一成以下任何形式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line"><span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">[]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">[]<span class="keyword">map</span>[T1]<span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<p>（这个列表当然也不是专有的；有一个无限的数字类型不能被成功统一）</p>
<p>一般我们可以在两边都有类型参数，所以在某些情况下，我们可能会将 T1 与例如 T2 或 []T2 相联。</p>
<h3 id="函数参数类型推断"><a href="#函数参数类型推断" class="headerlink" title="函数参数类型推断"></a>函数参数类型推断</h3><p>函数参数类型推断是与函数调用一起使用的，从非类型参数推断类型参数。函数参数类型推断不是用在类型实例化的时候，并且当函数实例化且没有调用的时候也不使用。</p>
<p>去看一下它怎么工作，让我们回去看一下调用 Print 函数的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Print[<span class="keyword">int</span>]([]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>在这个函数调用中的类型参数 int 可以从非类型参数的类型中推断出来。</p>
<p>唯一可以被推断的类型参数是那些用于函数（非类型）输入参数类型的参数。如果有一些类型参数只用作函数的结果参数类型，或者只在函数体中，那么这些类型参数不能使用函数参数类型推断出来。</p>
<p>推断函数类型参数，我们将函数调用的参数与函数的非类型参数统一起来。在调用者这边，我们有真实的（非类型）参数的类型列表，对于 Print 例子来说就是 []int。在函数这边是函数的非类型参数的类型列表，对于 Print 来说就是 []T。在列表中，我们丢弃函数端不使用类型参数的各个参数。然后我们必须对剩下的参数类型应用类型统一。</p>
<p>函数参数类型推断是一个两阶段的算法。在第一阶段，我们在调用端忽略没有类型的常量和它们在函数定义中对应的类型。我们使用两阶段以便在一些情况下，后面的参数可以被没有类型的常量的类型来决定。</p>
<p>我们统一列表中的相应类型。这将使我们将函数侧的类型参数与调用方的类型联系起来。如果同样的类型参数在函数侧出现了多次，它将在调用侧匹配多个参数类型。如果这些调用侧的类型不等价，我们报一个错误。</p>
<p>第一个阶段之后，我们检查在调用侧的任意一个没有类型的常量。如果没有无类型常量，或者如果对应的函数类型中类型参数已经匹配了其它输入类型，那类型统一就完成了。</p>
<p>否则，对第二阶段来说，对任意一个对应函数类型还没有设置的无类型常量，我们按常规方法来决定无类型常量的默认类型。然后我们再次统一剩下的类型，这次没有无类型常量。</p>
<p>当约束类型推断是可能的时候，像下面描述的，它在两个阶段中应用。</p>
<p>在这个例子中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">Print(s1)</span><br></pre></td></tr></table></figure>
<p>我们比较 []int 和 []T，匹配到 T 和 int，那么我们就完成了。单个类型参数 T 是 int，所以我们推断 Print 的调用实际上是 Print[int]。</p>
<p>一个更复杂的例子，思考</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map 在 slice s 中的每个元素上调用函数 f, 返回一个新的 slice</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Map</span>[<span class="title">F</span>, <span class="title">T</span> <span class="title">any</span>]<span class="params">(s []F, f <span class="keyword">func</span>(F)</span> <span class="title">T</span>) []<span class="title">T</span></span> &#123;</span><br><span class="line">	r := <span class="built_in">make</span>([]T, <span class="built_in">len</span>(s))</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		r[i] = f(v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个类型参数 F 和 T 都用作输入参数，所以函数参数类型推断是可能的。在调用中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strs := Map([]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, strconv.Itoa)</span><br></pre></td></tr></table></figure>
<p>我们统一 []int 和 []F，匹配到 F 和 int。我们统一 strconv.Itoa 的类型，它是 func(int) string，和 func(F) T，匹配到 F 和 int，T 和 string。类型参数 F 匹配了两次，每次都是 int。统一成功，所以 Map 的调用就是 Map[int, string] 的调用。</p>
<p>看一下无类型常量规则的效率，思考：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewPair 返回同样类型值的 Pair</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPair</span>[<span class="title">F</span> <span class="title">any</span>]<span class="params">(f1, f2 F)</span> *<span class="title">Pair</span>[<span class="title">F</span>]</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>在 NewPair(1, 2) 调用中，所以参数都是无类型常量，所以在第一阶段都忽略了。没有任何东西被统一。第一阶段后，我们仍然有两个无类型常量。都设置成了它们的默认类型，int。第二次类型统一阶段统一 F 和 int，所以最终的调用是 <code>NewPair[int](1, 2)</code>。</p>
<p>在<code>NewPair(1, int64(2))</code>的调用中，第一个参数是无类型参数，所以我们在第一阶段忽略它。我们然后统一 int64 和 F。在这点，无类型常量对应的类型参数是全确定的，所以最终调用是<code>NewPair[int64](1, int64(2))</code>。</p>
<p>在<code>NewPair(1, 2.5)</code>的调用中，所有参数都是无类型常量，所以我继续第二阶段。这次我们设置第一个参数为int, 第二个参数为float64。然后我们尝试统一 F 与 int 和 float64，所以统一失败，然后我们报一个错误。</p>
<p>像之前提到的，函数参数类型推断是不管约束的。首先我们使用函数参数类型推断来确定用于函数的类型参数，然后，如果成功，我们检查这些类型参数是否实现了约束（如果有）。</p>
<p>注意函数参数类型成功推断之后，编译器仍然必须检查实参赋值给形参，就像任何函数调用一样。</p>
<h3 id="约束类型推断"><a href="#约束类型推断" class="headerlink" title="约束类型推断"></a>约束类型推断</h3><p>约束类型推断允许基于类型参数约束，从另一个类型参数推断一个类型参数。当函数想要为某个其他类型参数的元素指定类型名称时，或者当函数想要将约束应用于基于某个其他类型参数的类型时，约束类型推断很有用。</p>
<p>约束类型推断只可以推断这些类型，如果一些类型参数有约束且类型集中只有一个类型，或者类型集中的类型底层类型都是一种类型。这两种情况略有不同，因为在第一种情况中，类型集中只有一个类型，单个类型不需要它的底层类型。另一种，单个类型叫做结构类型，并且约束叫做结构约束。结构类型描述了类型参数需要的类型。结构约束可能也定义了方法，不过方法会被约束类型推断忽略。对于约束类型推断是有用的，结构类型将用一个或更多的类型参数来正常定义。</p>
<p>约束类型推断只有在至少有一个类型参数且类型参数未知时才会尝试。</p>
<p>我们这里描述的算法可能比较复杂，典型的具体例子可以直观看到约束类型推断出什么。算法的描述后面有一些例子。</p>
<p>我们通过创建一个类型形参到实参的映射来开始。我们用所有类型参数且它的类型参数是已知的来初始化映射，如果存在的话。</p>
<p>对于每个有结构化约束的类型参数，我们用结构化类型统一类型参数。将类型参数与它的约束联系起来，将会有用。我们把结果添加到我们维护的映射中。如果统一发现了任何类型参数的关联，我们也将它添加到映射中。当我们发任何一个类型参数的多个关联，我们统一每个这样的关联以产生一个单个的映射记录。如果一个类型参数直接与另一个类型参数关联，意味着它们必须都匹配到同一个类型，我们一起统一每个参数的关联。如果这些统一中任意一个失败了，那么约束类型推断就会失败。</p>
<p>将所有类型参数与结构化约束合并之后，我们将有一个各种类型参数到类型（也可能含有其它的类型参数）的映射。我们继续寻找一个类型参数 T，它映射到一个完全知道的类型参数A，它不包含任何类型参数。在映射的类型参数中出现T的任何地方，我们将T替换成A。我们重复这些过程，直到我们替换了每个类型参数。</p>
<p>当约束类型推断可能的时候，类型推断继续像下面这样执行：</p>
<ul>
<li>用已知类型参数组建一个映射。</li>
<li>应用约束类型推断。</li>
<li>用类型参数应用函数类型推断。</li>
<li>再次应用约束类型推断。</li>
<li>使用任何剩余无类型参数的默认类型，应用函数类型推断</li>
<li>再次应用约束类型推断</li>
</ul>
<h4 id="元素约束例子"><a href="#元素约束例子" class="headerlink" title="元素约束例子"></a>元素约束例子</h4><p>一个约束类型推断有用的例子，让我们考虑一个函数，它接受一个定义类型的数字切片，并且返回一个相同定义类型的实例，其中每个数字都加倍。</p>
<p>如果我们忽略定义类型的要求，写一个类似的函数是非常容易的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Double 返回一个新的切片，其中包含s中所有的元素，并双倍。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Double</span>[<span class="title">E</span> <span class="title">constraints</span>.<span class="title">Integer</span>]<span class="params">(s []E)</span> []<span class="title">E</span></span> &#123;</span><br><span class="line">	r := <span class="built_in">make</span>([]E, <span class="built_in">len</span>(s))</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		r[i] = v + v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，根据这个定义，如果我们用定义好的切片类型调用函数，结果将不是那个定义的类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MySlice 是一个 int 的切片</span></span><br><span class="line"><span class="keyword">type</span> MySlice []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// V1的类型将是 []int, 不是 MySlice.</span></span><br><span class="line"><span class="comment">// 这里我们使用函数参数类型推断。</span></span><br><span class="line"><span class="comment">// 而不是约束类型推断</span></span><br><span class="line"><span class="keyword">var</span> V1 = Double(MySlice&#123;<span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们可以通过引入一个新的类型参数来实现。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DoubleDefined 返回一个新的切片类型，其中包含s中的每个元素，</span></span><br><span class="line"><span class="comment">// 双倍，并且也有跟 s 一样的类型。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoubleDefined</span>[<span class="title">S</span> ~[]<span class="title">E</span>, <span class="title">E</span> <span class="title">constraints</span>.<span class="title">Integer</span>]<span class="params">(s S)</span> <span class="title">S</span></span> &#123;</span><br><span class="line">	<span class="comment">// 注意这里我们传 S 给 make，上面我们传 []E</span></span><br><span class="line">	r := <span class="built_in">make</span>(S, <span class="built_in">len</span>(s))</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		r[i] = v + v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在如果我们使用明确的类型参数，我们可以得到正确的类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V2 的类型将是 MySlice.</span></span><br><span class="line"><span class="keyword">var</span> V2 = DoubleDefined[MySlice, <span class="keyword">int</span>](MySlice&#123;<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>这里函数参数推断通过自己是不够推断出类型参数的，因为类型参数 E 没有被任何输入参数使用。但是结合函数参数类型推断和约束类型推断就可以推断出。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V3 的类型将是 MySlice.</span></span><br><span class="line"><span class="keyword">var</span> V3 = DoubleDefined(MySlice&#123;<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>首先我们应用函数参数类型推断。我们看到参数的类型是 MySlice。函数参数类型推断匹配到类型参数 S 和 MySlice。</p>
<p>然后我们继续到约束类型推断。我们知道一个类型参数，S。我们看到类型参数 S 有一个结构类型约束。</p>
<p>我们用知道的类型参数创建一个映射：</p>
<p>{S -&gt; MySlice}</p>
<p>我们然后使用带有约束类型集中只有单个类型的约束来统一类型参数。在这个例子中，结构约束是 <code>~[]E</code>，它有结构类型<code>[]E</code>，所以我们使用<code>[]E</code>统一 S。因为我们已经有一个对 S 的映射，我们然后用 MySlice 统一<code>[]E</code>。因为 MySlice 是定义成<code>[]int</code>，这关联 E 和 int。我们现在有：</p>
<p>{S -&gt; MySlice, E -&gt; int}</p>
<p>我们然后用 int 替换 E，这什么也不改变，然后我们完成了。这次对 DoubleDefined 的调用类型参数是 <code>[MySlice, int]</code>。</p>
<p>这个例子显示了我们怎么使用约束类型推断为其它类型参数设置类型名字。在这个例子中，我们可以把 S 的元素类型命名为 E，并且我们之后应用约束到 E，在这个例子中，需要它是个数字。</p>
<h4 id="指针方法例子"><a href="#指针方法例子" class="headerlink" title="指针方法例子"></a>指针方法例子</h4><p>思考这个例子：函数希望一个类型 T 有一个 Set(string) 方法，它使用 string 来初始化值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Setter 是一个类型约束, 它需要类型实现 Set 方法从 string 设置值。</span></span><br><span class="line"><span class="keyword">type</span> Setter <span class="keyword">interface</span> &#123;</span><br><span class="line">	Set(<span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FromStrings 接受一个字符串切片，并返回一个 T 的切片，调用 Set 方法来设置每个返回值。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 注意因为 T 只用作结构参数，当调用这个函数时，函数参数类型推断不能工作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FromStrings</span>[<span class="title">T</span> <span class="title">Setter</span>]<span class="params">(s []<span class="keyword">string</span>)</span> []<span class="title">T</span></span> &#123;</span><br><span class="line">	result := <span class="built_in">make</span>([]T, <span class="built_in">len</span>(s))</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		result[i].Set(v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在让我们看看一些调用代码（这个例子是无效的）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Settable 是一个整数类型，可以设置字符串。</span></span><br><span class="line"><span class="keyword">type</span> Settable <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set 从字符串设置 *p 的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Settable)</span> <span class="title">Set</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    i, _ := strconv.Atoi(s) <span class="comment">// 真实的代码不应该忽略 error</span></span><br><span class="line">    *p = Settable(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 无效的。</span></span><br><span class="line">    nums := FromStrings[Settable]([]<span class="keyword">string</span>&#123;<span class="string">"1"</span>, <span class="string">"2"</span>&#125;)</span><br><span class="line">    <span class="comment">// 这里我们想让 nums 是 []Settable&#123;1, 2&#125;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目标是使用 FromString 得到一个 []Settable 类型的切片。不幸的是，这个例子是无效，并且无法编译。</p>
<p>问题是 FromStrings 需要拥有 Set(string) 方法的类型。这个函数 F 尝试使用 Settable 去实例化 FromStrings，不过 Settable 没有 Set 方法。拥有 Set 方法的类型是 *Settable。</p>
<p>所以让我们使用 *Settable 来重写 F。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 编译通过了但是没有像想的那样工作。</span></span><br><span class="line">    <span class="comment">// 在运行时，调用 Set 方法将会 panic.</span></span><br><span class="line">    nums := FromStrings[*Settable]([]<span class="keyword">string</span>&#123;<span class="string">"1"</span>, <span class="string">"2"</span>&#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这能编译通过，不过不幸的是，它在运行时会 panic。问题是 FromStrings 创建了一个切片类型<code>[]T</code>。当使用 *Settable 初始化的时候，这意味着切片类型是<code>[]*Settable</code>。当 FromStrings 调用 <code>result[i].Set(v)</code>时，这将在存储在<code>result[i]</code>中的指针上，调用 Set 方法。这个指针是 nil。Settable.Set 将在一个 nil 接受者上被调用，然后因为 nil 解引用失败，将会引起 panic。</p>
<p>指针类型 *Settable 实现了约束，不过代码真的想要使用非指针类型 Settable。我们需要的是一种方法来写 FromStrings 以便于它可以接受类型 Settable 作为参数，但是调用一个指针方法。重复一下，我们不能用 Settable，因为它没有 Set 方法，并且我们也不能使用 *Settable 因为我们不能创建类型 Settable 的切片。</p>
<p>我们可以做的是两个类型都传递。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Setter2 是一个类型约束，它要求类型实现 Set 方法用 String 设置值。</span></span><br><span class="line"><span class="comment">// 并且也要求类型是一个指向它自己的指针。</span></span><br><span class="line"><span class="keyword">type</span> Setter2[B any] <span class="keyword">interface</span> &#123;</span><br><span class="line">	Set(<span class="keyword">string</span>)</span><br><span class="line">	*B <span class="comment">// 非接口类型约束元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FromStrings2 接受strings 切片，并返回 T 的切片，</span></span><br><span class="line"><span class="comment">// 调用每个元素的 Set 方法来设置返回值。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 我们用两个不同的类型参数以便于我们可以返回一个 T 的切片，但是调用 *T 的方法.</span></span><br><span class="line"><span class="comment">// Setter2 约束确保 PT 是一个指向 T 的指针。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FromStrings2</span>[<span class="title">T</span> <span class="title">any</span>, <span class="title">PT</span> <span class="title">Setter2</span>[<span class="title">T</span>]]<span class="params">(s []<span class="keyword">string</span>)</span> []<span class="title">T</span></span> &#123;</span><br><span class="line">	result := <span class="built_in">make</span>([]T, <span class="built_in">len</span>(s))</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		<span class="comment">// &amp;result[i] 的类型是 *T，它在 Setter2 的类型集中，所以我们可以把它转换成 PT。</span></span><br><span class="line">		p := PT(&amp;result[i])</span><br><span class="line">		<span class="comment">// PT 有 Set 方法。</span></span><br><span class="line">		p.Set(v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以像这样调用 FromStrings2:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// FromStrings2 接受两个参数。</span></span><br><span class="line">	<span class="comment">// 第二个参数必须是指向第一个参数的指针。</span></span><br><span class="line">	<span class="comment">// Settable 就像上面一样。</span></span><br><span class="line">	nums := FromStrings2[Settable, *Settable]([]<span class="keyword">string</span>&#123;<span class="string">"1"</span>, <span class="string">"2"</span>&#125;)</span><br><span class="line">	<span class="comment">// 现在 nums 是 []Settable&#123;1, 2&#125;.</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种像期待的那样有效，不过它必须笨拙的在类型参数中重复 Settable。幸运的是，约束类型推断可以减少重复。使用约束类型推断我们可以这样写</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F3</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 这里我们只传一个类型参数</span></span><br><span class="line">	nums := FromStrings2[Settable]([]<span class="keyword">string</span>&#123;<span class="string">"1"</span>, <span class="string">"2"</span>&#125;)</span><br><span class="line">	<span class="comment">// 现在 nums 是 []Settable&#123;1, 2&#125;.</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有办法不传类型参数 Settable。但是给定类型参数，约束类型推断可以为类型参数 PT 推断出 *Settable。</p>
<p>像之前一样，我们创建一个已知类型参数的映射：</p>
<p>{T -&gt; Settable}</p>
<p>我们用结构约束统一每个类型参数。在这个例子中，我们使用单个类型 Setter2[T] 来统一 PT，它是 *T。现在映射是</p>
<p>{T -&gt; Settable, PT -&gt; *T}</p>
<p>我们把所有的 T 替换成 Settable，得到：</p>
<p>{T -&gt; Settable, PT -&gt; *Settable}</p>
<p>这之后没有什么改变，并且我们完成了。所有类型参数都是已知的。</p>
<p>这个例子显示了我们怎么使用约束类型推断来将约束应用到基于其它类型参数的类型上。在这个例子中我们说的 PT，是个 *T 类型，必须有 Set 方法。不需要调用者明确提到 *T 我们就可以做到这一点。</p>
<h4 id="即使在约束类型推断之后也应用约束"><a href="#即使在约束类型推断之后也应用约束" class="headerlink" title="即使在约束类型推断之后也应用约束"></a>即使在约束类型推断之后也应用约束</h4><p>即使当约束类型推断已经基于约束来推断类型参数，类型参数确定后，我们仍然必须检查约束。</p>
<p>在上面的 FromStrings2 的例子中，我们能基于 Setter2 来推断出 PT 的类型参数。但是这期间我们只寻找了类型集，我们不看方法。我们仍然必须检查方法也有，满足约束，即使约束类型推断成功了。</p>
<p>例如，思考这个无效的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unsettable 是一个没有 Set 方法的类型。</span></span><br><span class="line"><span class="keyword">type</span> Unsettable <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F4</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 这个调用是无效的</span></span><br><span class="line">	nums := FromStrings2[Unsettable]([]<span class="keyword">string</span>&#123;<span class="string">"1"</span>, <span class="string">"2"</span>&#125;)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当这个调用发生时，我们在调用前应用约束类型推断。这可能成功，并且推断出类型参数是<code>[Unsettable, *Unsettable]</code>。只有当约束类型推断完成之后，我们检查 *Unsettable 是否实现了约束 <code>Setter2[Unsettable]</code>。因为 *Unsettable 没有 Set 方法，约束检查将会失败，这个代码将不会编译。</p>
<h4 id="使用在约束中引用自己的类型"><a href="#使用在约束中引用自己的类型" class="headerlink" title="使用在约束中引用自己的类型"></a>使用在约束中引用自己的类型</h4><p>对于泛型函数来说，需要一个类型参数和一个参数是类型本身的方法是很有用的。例如，这将自然引起方法比较。（注意我们这里讨论的是方法，不是操作符）假设我们想要写一个 Index 方法，它使用 Equal 方法来检查是否发现期望的值。我们这么写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Index 返回 e 在 s 中的索引，如果没有找到，返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span>[<span class="title">T</span> <span class="title">Equaler</span>]<span class="params">(s []T, e T)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		<span class="keyword">if</span> e.Equal(v) &#123;</span><br><span class="line">			<span class="keyword">return</span> i</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了写 Equaler 约束，我们必须写一个约束，它能引用传入的类型参数。最容易做到的方法是利用约束不必定义类型，它可以只是简单的接口类型文字。接口类型的文字然后引用类型参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Index 返回 e 在 s 中的索引，如果没有找到就返回 -1.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span>[<span class="title">T</span> <span class="title">interface</span></span> &#123; Equal(T) <span class="keyword">bool</span> &#125;](s []T, e T) <span class="keyword">int</span> &#123;</span><br><span class="line">	<span class="comment">// 跟上面一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个版本的 Index 可能与像这种定义的类型 equalInt 一样使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equalInt 一个实现了 Equaler 的 int.</span></span><br><span class="line"><span class="keyword">type</span> equalInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Equal 方法让 equalInt 实现 Equaler 约束。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a equalInt)</span> <span class="title">Equal</span><span class="params">(b equalInt)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a == b &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// indexEqualInts 返回 e 在 s 中的索引，如果没有找到返回 -1.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexEqualInt</span><span class="params">(s []equalInt, e equalInt)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 类型参数 equalInt 显示在这里是为了更明显。</span></span><br><span class="line">	<span class="comment">// 函数参数类型推断允许去掉它。</span></span><br><span class="line">	<span class="keyword">return</span> Index[equalInt](s, e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，当我们把 equalInt 传给 Index，我们检查 equalInt 是否实现了约束<code>interface { Equal(T) bool }</code>。约束有一个类型参数，所以我们用传入的实参（就是 equalInt）替换类型参数。这给我们一个<code>interface { Equal(equalInt) bool}</code>。equalInt 类型有一个 Equal 方法有这样的签名，所以它是符合的，编译可以成功。</p>
<h2 id="类型参数的值是没有装箱的"><a href="#类型参数的值是没有装箱的" class="headerlink" title="类型参数的值是没有装箱的"></a>类型参数的值是没有装箱的</h2><p>在当前的 Go 实现中，接口类型的值总是持有指针。把一个非指针的值赋给一个接口类型变量，会引用这个值被装箱。这意味着真实的值被放在别的某个地方了，堆或栈中，并且接口类型持有一个指向那个位置的指针。</p>
<p>在这种设计中，泛型类型的值是不装箱的。例如，我们回过头去看一下之前的例子 FromStrings2。当它用类型 Settable 来初始化的时候，它返回一个<code>[]Settable</code>类型的值。例如，我们可以写</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Settable 是一个整数类型，可以用字符串设置值。</span></span><br><span class="line"><span class="keyword">type</span> Settable <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set 用字符串来设置 *p 的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Settable)</span> <span class="title">Set</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 跟上面一样</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// nums 的类型是 []Settable.</span></span><br><span class="line">	nums := FromStrings2[Settable]([]<span class="keyword">string</span>&#123;<span class="string">"1"</span>, <span class="string">"2"</span>&#125;)</span><br><span class="line">	<span class="comment">// Settable 可以直接转换成 int</span></span><br><span class="line">	<span class="comment">// 这将会把 first 设置成 1</span></span><br><span class="line">	first := <span class="keyword">int</span>(nums[<span class="number">0</span>])</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们用 Settable 实例化来调用 FromStrings2 的时候，我们得到一个 <code>[]Settable</code> 类型。切片的元素将是 Settable 的值，那就是说，它们将是整数。他们没有被装箱，即使它们被泛型函数合建和设置。</p>
<p>相似的，当一个泛型函数被实例化，它将像组合一样会有期望的类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pair[F1, F2 any] <span class="keyword">struct</span> &#123;</span><br><span class="line">	first  F1</span><br><span class="line">	second F2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当这个被实例化，字段将不会被装箱，没有期望外的内存被分配。类型<code>Pair[int, string]</code>被转换成<code>struct { first int; second string }</code>。</p>
<h2 id="更多关于类型集合的内容"><a href="#更多关于类型集合的内容" class="headerlink" title="更多关于类型集合的内容"></a>更多关于类型集合的内容</h2><p>现在让我们回到类型集来涵盖一些仍然值得注意的不太重要的细节。</p>
<h3 id="元素和方法都在约束中"><a href="#元素和方法都在约束中" class="headerlink" title="元素和方法都在约束中"></a>元素和方法都在约束中</h3><p>就像在前面看到的 Setter2 一样，约束可能同时使用约束元素和方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StringableSignedInteger 是类型约束，它匹配任何满足下面两个条件的类型：</span></span><br><span class="line"><span class="comment">// 1) 定义为一个有符号整数类型。</span></span><br><span class="line"><span class="comment">// 2) 有 String 方法。</span></span><br><span class="line"><span class="keyword">type</span> StringableSignedInteger <span class="keyword">interface</span> &#123;</span><br><span class="line">	~<span class="keyword">int</span> | ~<span class="keyword">int8</span> | ~<span class="keyword">int16</span> | ~<span class="keyword">int32</span> | ~<span class="keyword">int64</span></span><br><span class="line">	String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型集的规则定义了这意味着什么。union 元素的类型集是其底层类型是预先声明的有符号整数类型之一的所有类型的集合。<code>String() string</code>的类型集是所有定义了这个方法的类型。StringableSignedInteger 的类型集是这两个类型的交集。结果是所有底层类型是预定义的有符号整数且定义了 String() string 方法的集合。使用 StringSignedInteger 作为约束的参数化类型 P 的函数可以对类型 P 的值使用任何整数类型（+，*, 等）所允许的操作。它也可以对值调用 String 方法以获取字符串。</p>
<p>值得注意的是这里的 ~。StringableSignedInteger 约束使用 ~int，不是 int。类型 int 本身不允许作为类型参数，因为它没有 String 方法。允许类型参数的一个示例是 MyInt，定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyInt 是可字符串化的 int.</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String 方法返回字符代表的 mi</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mi MyInt)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"MyInt(%d)"</span>, mi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="约束中的组合类型"><a href="#约束中的组合类型" class="headerlink" title="约束中的组合类型"></a>约束中的组合类型</h3><p>像我们在之前的一些例子中看到的一样，约束元素可以是类型字面量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> byteseq <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="keyword">string</span> | []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常的规则应用：这个约束的类型参数可能是 string 或者 <code>[]byte</code>；使用这个约束的泛型函数可以使用任何被 string 和 <code>[]byte</code>同时允许的操作。</p>
<p>byteseq 约束允许写对 string 和 <code>[]byte</code>都有用的泛型函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Join 连接它第一个参数的元素以创造一个单个的值。seq 是结果中放在元素中间的。</span></span><br><span class="line"><span class="comment">// Join 对 string 和 []byte 类型都有效</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span>[<span class="title">T</span> <span class="title">byteseq</span>]<span class="params">(a []T, sep T)</span> <span class="params">(ret T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(a) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 使用结果参数当零值；</span></span><br><span class="line">		<span class="comment">// 见 Issues 区的零值讨论</span></span><br><span class="line">		<span class="keyword">return</span> ret</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(a) == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="comment">// 我们知道 a[0] 是 string 或 []byte.</span></span><br><span class="line">		<span class="comment">// 我们可以追加 string 或 []byte 到 []byte，产生一个 []byte.</span></span><br><span class="line">        <span class="comment">// 我们可以转换 []byte 到 []byte (什么都不做的转换) 或 string。</span></span><br><span class="line">		<span class="keyword">return</span> T(<span class="built_in">append</span>([]<span class="keyword">byte</span>(<span class="literal">nil</span>), a[<span class="number">0</span>]...))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 因为我们可以调用 string 或 []byte 的 Len，所以我们能调用 seq 的 len.</span></span><br><span class="line">	n := <span class="built_in">len</span>(sep) * (<span class="built_in">len</span>(a) - <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">		<span class="comment">// 调用 string 或 []byte 的 len 的另一个例子。</span></span><br><span class="line">		n += <span class="built_in">len</span>(v)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, n)</span><br><span class="line">	<span class="comment">// 我们可以调用 copy</span></span><br><span class="line">	bp := <span class="built_in">copy</span>(b, a[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> a[<span class="number">1</span>:] &#123;</span><br><span class="line">		bp += <span class="built_in">copy</span>(b[bp:], sep)</span><br><span class="line">		bp += <span class="built_in">copy</span>(b[bp:], s)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 像上面一样，我们可以把 b 转换成 []byte 或 string.</span></span><br><span class="line">	<span class="keyword">return</span> T(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于组合类型（string, pointer, array, slice, struct, function, map, channel）我们强加一个额外的限制：仅当运算符接受相同的输入类型（如果有）并为类型集中的所有类型生成相同的结果类型时，才可以使用操作。需要明确的是，仅当组合类型出现在类型集中时才施加此附加限制。当组合类型由类型集之外的类型参数形成时，它不适用，例如某些类型参数 T 的 var v []T。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// structField 是一个由一些带有字段名 x 的 struct 类型组成的类型约束。</span></span><br><span class="line"><span class="keyword">type</span> structField <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> &#123; a <span class="keyword">int</span>; x <span class="keyword">int</span> &#125; |</span><br><span class="line">		<span class="keyword">struct</span> &#123; b <span class="keyword">int</span>; x <span class="keyword">float64</span> &#125; |</span><br><span class="line">		<span class="keyword">struct</span> &#123; c <span class="keyword">int</span>; x <span class="keyword">uint64</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数是无效的。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IncrementX</span>[<span class="title">T</span> <span class="title">structField</span>]<span class="params">(p *T)</span></span> &#123;</span><br><span class="line">	v := p.x <span class="comment">// 无效：p.x 的类型对于类型集中的类型并不一致。</span></span><br><span class="line">	v++</span><br><span class="line">	p.x = v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sliceOrMap 是一个用于 slice 或 map 的类型约束。</span></span><br><span class="line"><span class="keyword">type</span> sliceOrMap <span class="keyword">interface</span> &#123;</span><br><span class="line">	[]<span class="keyword">int</span> | <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Entry 返回 slice 中的第 i 个记录或者 map 中 key 为 i 的值。</span></span><br><span class="line"><span class="comment">// 这是有效的因为操作符的结果总是 int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Entry</span>[<span class="title">T</span> <span class="title">sliceOrMap</span>]<span class="params">(c T, i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 这是 slice 的索引操作或者 map 的 key 查询。</span></span><br><span class="line">	<span class="comment">// 无论哪种，索引和结果类型都是 Int</span></span><br><span class="line">	<span class="keyword">return</span> c[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sliceOrFloatMap 是一个 slice 或 map 的类型约束</span></span><br><span class="line"><span class="keyword">type</span> sliceOrFloatMap <span class="keyword">interface</span> &#123;</span><br><span class="line">	[]<span class="keyword">int</span> | <span class="keyword">map</span>[<span class="keyword">float64</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数是无效的。</span></span><br><span class="line"><span class="comment">// 在这个例子中 index 操作的输入类型是 int (对于 slice) 或 float64 (对于 map)，所以操作不允许。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FloatEntry</span>[<span class="title">T</span> <span class="title">sliceOrFloatMap</span>]<span class="params">(c T)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c[<span class="number">1.0</span>] <span class="comment">// 无效：输入类型是 int 或 float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加这个限制使用在泛型函数中理解一些操作的类型更加容易了。它避免了基于对类型集的每个元素应用一些操作来引入具有构造类型集的值的概念。</p>
<p>（注意：对人们想要怎么写代码理解的越多，在将士为可以会放松这个限制）</p>
<h3 id="类型集合中的类型参数"><a href="#类型集合中的类型参数" class="headerlink" title="类型集合中的类型参数"></a>类型集合中的类型参数</h3><p>在约束元素中的类型字面量可以引用约束中的类型参数。在这个例子中，泛型函数 Map 接受两个类型参数。第一个类型参数要求有一个底层类型是第二个类型参数的切片。第二个类型参数没有约束限制。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SliceConstraint 是一个匹配类型参数切片的约束。</span></span><br><span class="line"><span class="keyword">type</span> SliceConstraint[T any] <span class="keyword">interface</span> &#123;</span><br><span class="line">	~[]T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map 接受一些元素类型的切片和一个转换函数，并且返回一个切片，其中函数应用到每个元素上。</span></span><br><span class="line"><span class="comment">// Map 返回的切片的类型跟它的切片参数是一样的，即使那是一个定义的类型。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Map</span>[<span class="title">S</span> <span class="title">SliceConstraint</span>[<span class="title">E</span>], <span class="title">E</span> <span class="title">any</span>]<span class="params">(s S, f <span class="keyword">func</span>(E)</span> <span class="title">E</span>) <span class="title">S</span></span> &#123;</span><br><span class="line">	r := <span class="built_in">make</span>(S, <span class="built_in">len</span>(s))</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		r[i] = f(v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MySlice 是一个简单的自定义类型。</span></span><br><span class="line"><span class="keyword">type</span> MySlice []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DoubleMySlice 接受一个 MySlice 类型的值，然后返回一个新的 MySlice 的值，</span></span><br><span class="line"><span class="comment">// 其中每个元素的值是原来的双倍。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoubleMySlice</span><span class="params">(s MySlice)</span> <span class="title">MySlice</span></span> &#123;</span><br><span class="line">	<span class="comment">// 这里明确列出的类型参数可以被推断出来。</span></span><br><span class="line">	v := Map[MySlice, <span class="keyword">int</span>](s, <span class="function"><span class="keyword">func</span><span class="params">(e <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="number">2</span> * e &#125;)</span><br><span class="line">	<span class="comment">// 这里 v 是 MySlice 类型，不是 []int 类型。</span></span><br><span class="line">	<span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在之前讨论约束类型推断的时候，我们展示过类型这种的例子。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>在一个有两个类型参数 From 和 To 的函数中，如果在 From 约束类型集中的所有类型都可以转换成所有在 To 约束类型集中的类型，From 类型的值可以转成 To 类型的值。</p>
<p>这是个普遍规则的结果：泛型函数可以使用被类型集中所有类型都允许的任何操作。</p>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> integer <span class="keyword">interface</span> &#123;</span><br><span class="line">	~<span class="keyword">int</span> | ~<span class="keyword">int8</span> | ~<span class="keyword">int16</span> | ~<span class="keyword">int32</span> | ~<span class="keyword">int64</span> |</span><br><span class="line">		~<span class="keyword">uint</span> | ~<span class="keyword">uint8</span> | ~<span class="keyword">uint16</span> | ~<span class="keyword">uint32</span> | ~<span class="keyword">uint64</span> | ~<span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Convert</span>[<span class="title">To</span>, <span class="title">From</span> <span class="title">integer</span>]<span class="params">(from From)</span> <span class="title">To</span></span> &#123;</span><br><span class="line">	to := To(from)</span><br><span class="line">	<span class="keyword">if</span> From(to) != from &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"conversion out of range"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> to</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Convert 中的转换是允许的，因为 Go 允许整数被转换成任何其它整数类型。</p>
<h3 id="没有类型的常量"><a href="#没有类型的常量" class="headerlink" title="没有类型的常量"></a>没有类型的常量</h3><p>一些函数使用无类型常量。如果类型参数约束的类型集中的每个类型都允许使用类型参数的值，则允许使用无类型常量的值。</p>
<p>与类型转换一样，普遍规则的结果：泛型函数可以使用任何被类型集所有每个都允许的操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> integer <span class="keyword">interface</span> &#123;</span><br><span class="line">	~<span class="keyword">int</span> | ~<span class="keyword">int8</span> | ~<span class="keyword">int16</span> | ~<span class="keyword">int32</span> | ~<span class="keyword">int64</span> |</span><br><span class="line">		~<span class="keyword">uint</span> | ~<span class="keyword">uint8</span> | ~<span class="keyword">uint16</span> | ~<span class="keyword">uint32</span> | ~<span class="keyword">uint64</span> | ~<span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add10</span>[<span class="title">T</span> <span class="title">integer</span>]<span class="params">(s []T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		s[i] = v + <span class="number">10</span> <span class="comment">// 可以：10 可以转换成任何整数类型</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数是无效的。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add1024</span>[<span class="title">T</span> <span class="title">integer</span>]<span class="params">(s []T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		s[i] = v + <span class="number">1024</span> <span class="comment">// 无效的：1024 不被 int8/uint8 允许。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="嵌入的约束的类型集合"><a href="#嵌入的约束的类型集合" class="headerlink" title="嵌入的约束的类型集合"></a>嵌入的约束的类型集合</h3><p>当约束嵌入其它约束时，外面约束的类型集是所有涉及的类型集的交集。如果有多个嵌入类型，则交集保留任何类型参数必须满足所有约束元素的要求的属性。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Addable 是支持 + 操作符的类型</span></span><br><span class="line"><span class="keyword">type</span> Addable <span class="keyword">interface</span> &#123;</span><br><span class="line">	~<span class="keyword">int</span> | ~<span class="keyword">int8</span> | ~<span class="keyword">int16</span> | ~<span class="keyword">int32</span> | ~<span class="keyword">int64</span> |</span><br><span class="line">		~<span class="keyword">uint</span> | ~<span class="keyword">uint8</span> | ~<span class="keyword">uint16</span> | ~<span class="keyword">uint32</span> | ~<span class="keyword">uint64</span> | ~<span class="keyword">uintptr</span> |</span><br><span class="line">		~<span class="keyword">float32</span> | ~<span class="keyword">float64</span> | ~<span class="keyword">complex64</span> | ~<span class="keyword">complex128</span> |</span><br><span class="line">		~<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Byteseq 是字节序：string 或 []byte.</span></span><br><span class="line"><span class="keyword">type</span> Byteseq <span class="keyword">interface</span> &#123;</span><br><span class="line">	~<span class="keyword">string</span> | ~[]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddableByteseq 是支持 + 的字节序。</span></span><br><span class="line"><span class="comment">// 这是每个都是 Addable 和 Byteseq 的类型。</span></span><br><span class="line"><span class="comment">// 换句话说，只是类型集 ~string</span></span><br><span class="line"><span class="keyword">type</span> AddableByteseq <span class="keyword">interface</span> &#123;</span><br><span class="line">	Addable</span><br><span class="line">	Byteseq</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个嵌入约束可能出现在联合元素中。联合的类型集是，像平常一样，列在联合中的元素的类型集的并集。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Signed 是拥有所有有符号整数类型的约束。</span></span><br><span class="line"><span class="keyword">type</span> Signed <span class="keyword">interface</span> &#123;</span><br><span class="line">	~<span class="keyword">int</span> | ~<span class="keyword">int8</span> | ~<span class="keyword">int16</span> | ~<span class="keyword">int32</span> | ~<span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsigned 是拥有所有无符号整数类型集的约束。 </span></span><br><span class="line"><span class="keyword">type</span> Unsigned <span class="keyword">interface</span> &#123;</span><br><span class="line">	~<span class="keyword">uint</span> | ~<span class="keyword">uint8</span> | ~<span class="keyword">uint16</span> | ~<span class="keyword">uint32</span> | ~<span class="keyword">uint64</span> | ~<span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Integer 是拥有所有整数类型集的约束。</span></span><br><span class="line"><span class="keyword">type</span> Integer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Signed | Unsigned</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="联合元素中的-interface-类型"><a href="#联合元素中的-interface-类型" class="headerlink" title="联合元素中的 interface 类型"></a>联合元素中的 interface 类型</h3><p>我们说过联合元素的类型集是联合中所有类型的类型集的并集。对于大多数类型 T 它的类型集就是它自己。对于接口类型（和近似元素），不是这样的。</p>
<p>没有嵌入非接口元素的接口类型的类型集是，像我们之前说过的，所有声明了接口方法的类型，包含接口类型自己。在联合元素中使用这样的接口类型将把它的类型集添加到并集中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringish <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="keyword">string</span> | fmt.Stringer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Stringish 的类型集是 string 类型和所有实现了 fmt.Stringer 的类型。这些类型（包括 fmt.Stringer 自己）将被允许作为这个约束的类型参数。使用 Stringish 作为约束的类型参数中的值，什么操作都不允许（而不是所有都支持的操作）。这是因为 fmt.Stringer 在 Stringish 的类型集中，并且 fmt.Stringer，一个接口类型，不支持任何类型特定的操作。被 Stringish 允许的操作就是那些被类型集中所有类型都支持的操作，包括 fmt.Stringer，所以在这种情况下没有操作被允许，除非被全部类型都支持的。使用这个约束的参数化的函数必须使用类型断言或反射来使用值。仍然，在一些场景下对于强静态类型检查会非常有用。最主要的点是它直接来自约束满足和类型集的定义。</p>
<h3 id="空类型集合"><a href="#空类型集合" class="headerlink" title="空类型集合"></a>空类型集合</h3><p>写一个空类型集的约束是可能的。那将没有任何类型参数能满足这个约束，所以任何尝试去实例化一个拥有空类型集约束的函数将会失败。一般来讲让编译器去检查所有这种情况是不可能的。可能 vet 工具如果能检查出这种情况应该报错。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unsatisfiable 是一个拥有空类型集的约束。</span></span><br><span class="line"><span class="comment">// 没有预定义类型有这些方法。</span></span><br><span class="line"><span class="comment">// 如果这里使用 ~int | ~float32 类型集可能不是空的。</span></span><br><span class="line"><span class="keyword">type</span> Unsatisfiable <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="keyword">int</span> | <span class="keyword">float32</span></span><br><span class="line">	String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型集合注意事项"><a href="#类型集合注意事项" class="headerlink" title="类型集合注意事项"></a>类型集合注意事项</h3><p>明确的在约束列出类型可能显得很笨拙，但是很清楚在调用方允许哪些类型参数，以及泛型函数允许哪些操作。</p>
<p>如果语言之后修改了，变得支持操作符方法（现在还没有这个计划），那时约束像任何其它方法一样算是它们。</p>
<p>总是有一定数量的预定义类型，以及这些类型支持的一些操作。将来语言改变也不会从根本上改变这些事实，所以这种方式将继续有用。</p>
<p>这种方法不会尝试去处理每一个可能的操作。期望是在泛型函数和类型定义中的组合类型将被正常的当作组合类型处理，而不是将组合类型放入类型集中。例如，我们希望想在切片元素类型T上参数化索引切片的函数，使用<code>[]T</code> 类型的参数或变量。</p>
<p>就像上面 DoubleMySlice 的例子中看到的，这种方法将使得声明一个接受与返回组合类型，并且想返回跟参数一样类型的泛型函数更麻烦。定义组合类型不常见，但是确实可能出现。这个难点是这种方法的弱点。在调用方的约束类型推断可以提供帮助。</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>我不会提出以任何方式更改反射包的提案。当一个类型或函数被实例化时，所有的类型参数将会变成普通的非泛型类型。一个实例化类型的 reflect.Type 的 String 方法将会返回以类型参数在方括号中的方式的名字。例如，List[int]。</p>
<p>非泛型的代码不能引用一个没有实例化的泛型代码，所以未实例化的泛型类型或函数就没有反射信息。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Russ Cox 著名地观察到泛型需要在慢程序员，慢编译器，或慢的执行之间进行选择。</p>
<p>我们相信这个设计允许不同的实现选择。代码可能对于类型参数的每个集合分别编译，或者可以编译为每个类型参数的处理方式类似于带有方法调用的接口类型，或者可能是两者的某种组合。</p>
<p>换句话说，这个设计允许人们停止选择慢程序员，并且允许实现在慢编译器（单独编译每组类型参数）或慢执行时间之前决定（对于类型参数值上的每种操作使用方法调用）。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>虽然本文档冗长而详细，但实际设计减少了几个要点。</p>
<ul>
<li>函数和类型可以有类型参数，这些参数是使用约束来定义的，它们是接口类型。</li>
<li>约束描述了类型参数所需的方法和允许的类型。</li>
<li>约束描述了类型参数允许的方法和操作。</li>
<li>当调用带有类型参数的函数时，类型推断经常允许省略类型参数。</li>
<li>这个设计是完全后向兼容的。</li>
</ul>
<p>我们相信这个设计满足了人们对Go通用编程的需求，而不会使语言变得过于复杂。</p>
<p>如果没有多年的设计经验，我们无法真正了解对语言的影响。也就是说，这里有一些猜测。</p>
<h3 id="复杂性"><a href="#复杂性" class="headerlink" title="复杂性"></a>复杂性</h3><p>Go 很重要的一个特点是简单性。这设计无疑会让语言变得更复杂。</p>
<p>我们相信对于阅读编写良好的泛型代码而不是编写它的人来说，增加的复杂性是很小的。自然，人们必须学习声明类型参数的新语法。这个新语法，以及对于接口中类型集的新支持，都只是这个设计中的新的语法构造。泛型函数中的代码读起来像普通的 Go 代码，就像下面的例子中看到的一样。从 []int 到 []T 是个很容易的迁移。类型参数约束很有效率的作为文档，来描述类型。</p>
<p>我们希望大多数的包不会定义泛型类型或函数，但是很多包可能会使用在别外定义的泛型类型或函数。在常见情况下，泛型函数的工作方式与非泛型函数完全相同：你简单的调用它们。类型推断意味着你不需要必须明确地写出类型参数。类型推断规则的设计并不令人惊讶：类型参数被正确推断，或者调用失败并需要显式类型参数。类型推断使用类型等价，不尝试解析两种相似但不等价的类型，从而消除了显著的复杂性。</p>
<p>使用泛型类型的包必须明确伟类型参数。这个语法是直白的。唯一的改变是传参数给类型而不是只给函数。</p>
<p>一般来说，我们在设计尝试避免惊讶。只有时间将证明我们是否成功。</p>
<h3 id="无处不在的"><a href="#无处不在的" class="headerlink" title="无处不在的"></a>无处不在的</h3><p>我们希望在标准库中增加一些新的包。一个 slices 包，类似于现在的 bytes 包和 strings 包，操作任何元素类型的切片。新的 maps 和 chans 包，将提供现在为了每种元素类型重复的算法。会增加 sets 包。 </p>
<p>一个新的 constraints 包，提供标准的约束，例如允许所有整数或所有数字类型的约束。</p>
<p>像 container/list 和 container/ring 的包，和像 sync.Map 和 sync/atomic.Value 的类型，将被更新到编译时的类型安全，这些包将使用新的名字或新的版本。</p>
<p>math 包将会扩展以提供针对所有数字类型的标准算法，例如很流利的 Min 和 Max 函数。</p>
<p>我可能在 sort 包中增加泛型变量。</p>
<p>好像新特殊目的的编译时类型安全容器类型将被开发。</p>
<p>我不希望像 C++ STL 迭代器类型这样的方法被广泛使用。在 Go 中各种想法可以更自然的使用接口类型来表达。在 C++ 术语中，为迭代器使用接口类型可以被视为带有抽象损失，因为运行时效率低于实际上内联所有代码的 C++ 方法；我们相信 Go 程序员会继续发现这种损失是可以接受的。</p>
<p>当我们得到更多的容器类型，我们将开发一个标准的迭代器接口。这可能反过来导致修改语言以添加一些机制来使用带有 range 子句的迭代器压力。不过，这是非常把投机的。</p>
<h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><p>目前尚不清楚人们期望从泛型代码中获取什么样的效率。</p>
<p>泛型函数，而不是泛型类型，可能使用基于接口的方法来编译。这将优化编译时间，函数将只编译一次，但是将有一些运行时间成本。</p>
<p>泛型类型可以很自然的为每组参数编译多次。这将肯定带来编译时间消耗，但是没有运行时间消耗。编译可能选择像接口类型一样实现泛型类型，使用特殊的方法来访问每个依赖于类型参数的元素。</p>
<p>只有经验才会显示出人们在这一块希望什么。</p>
<h3 id="疏漏"><a href="#疏漏" class="headerlink" title="疏漏"></a>疏漏</h3><p>我们相信这个设计覆盖了泛型编程的基本需求。然而，还有一些编译构造是不支持的。</p>
<ul>
<li>没有泛型特化。没有办法去写一个多版本的泛型函数让它只对几个特殊的类型参数起作用。</li>
<li>没有无编程。没有办法去写在编译时运行，以产生运行时代码的代码。</li>
<li>没有高级别的抽象。一个带有类型参数的函数，如果不去调用它或实例化它，没有办法使用。一个泛型类型如果不实例化它，就没有办法使用。</li>
<li>没有泛型类型描述。为了在泛型函数中使用操作符，约束列出特定的类型，而不是描述类型必须的特性。这很容易理解，不过有时间是个限制。</li>
<li>函数参数没有协变和逆变。</li>
<li>没有操作符方法。你可以写一个编译时类型安全的泛型容器，但是你只能通过普通方法访问它，而不通使用像 c[k] 这样的语法。</li>
<li>没有柯里化。没有办法部分实例化一个泛型函数或类型，而不是通过一个帮助函数或者一个包装类型。所有的类型参数必须明确的传入或者在实例化时被推断出来。 </li>
<li>没有可变类型参数。不支持可变类型参数，这是允许写一个单个的泛型函数可以接受不同数量的类型参数和普通参数。</li>
<li>没有适配器。没有办法为约束定义一个适配器，让它支持那些没有实现这个约束的类型，比如，根据 Equal 方法定义 == 操作符，反之亦然。</li>
<li>无类型值无法参数化，比如常量。这在数组中最为明显，有进可以方便的编写类型 Matrix[n int][n][n]float64。有时为容器类型指定值也可能很有用，例如元素的默认值。</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>这个设计有一些问题应受更详细的讨论。我们认为这些问题与整体设计相比较小，但仍然值得完整的聆听和讨论。</p>
<h4 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h4><p>这个设计对于类型参数的零值没有简单的表达式。例如，思考这样一个例子，使用指针的可选值的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Optional[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">	p *T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o Optional[T])</span> <span class="title">Val</span><span class="params">()</span> <span class="title">T</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> o.p != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> *o.p</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> zero T</span><br><span class="line">	<span class="keyword">return</span> zero</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个情况下，o.p == nil，我们想要返回 T 的零值，但是我们没有办法去这么写。返回一个 nil 会不错，但是如果 T 是，就不能正常工作，说，int；在这个情况下，我们必须返回 0。而且，当然，没有办法去写一个约束来支持，返回 nil 或者 0.</p>
<p>针对这种情形的一些办法：</p>
<ul>
<li>使用<code>var zero T</code>，像上面一样，这在当前的设计下可以正常工作，不过需要一条额外的语句。</li>
<li>使用 <code>*new(T)</code>，这是隐秘的，不过在当前设计下有效。</li>
<li>只对结果来说， 命名结果参数，并且使用一个不带任何值的返回语句来返回一个零值。</li>
<li>扩展设计以允许使用 nil 作为任何泛型类型的零值（但是看问题 22729).</li>
<li>扩展设计以允许使用 T{}，这里 T 是类型参数，来表示这个类型的零值。</li>
<li>改变语言以允许在赋值语句的左边使用 _ （包括返回或函数调用）作为提案。</li>
<li>改变语言以允许返回 … 来返回结果类型的零值，在问题 21182 中提出。</li>
</ul>
<p>我们感觉决定在这里做（如果有的话）需要更多的设计经验。</p>
<h4 id="识别匹配的预声明类型"><a href="#识别匹配的预声明类型" class="headerlink" title="识别匹配的预声明类型"></a>识别匹配的预声明类型</h4><p>这个设计不提供任何方法来测试由 ~T 约束元素匹配的底层类型。代码可以通过转换为空接口类型并使用类型断言或类型切换的有点尴尬的方法来来测试实际的类型参数。但是这让代码可以测试实际的类型参数，它与底层类型不同。</p>
<p>这是一个例子，显示了不同之处。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Float <span class="keyword">interface</span> &#123;</span><br><span class="line">	~<span class="keyword">float32</span> | ~<span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewtonSqrt</span>[<span class="title">T</span> <span class="title">Float</span>]<span class="params">(v T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> iterations <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">switch</span> (<span class="keyword">interface</span>&#123;&#125;)(v).(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">float32</span>:</span><br><span class="line">		iterations = <span class="number">4</span></span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">		iterations = <span class="number">5</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"unexpected type %T"</span>, v))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Code omitted.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> G = NewtonSqrt(MyFloat(<span class="number">64</span>))</span><br></pre></td></tr></table></figure>
<p>当实例化G的时候，这个代码将会 panic，因为在 NewtonSqrt 函数中的 v 的类型是 MyFloat, 不是 float32 或 float64。这个函数真正想测试的不是 v 的类型，而是在约束类型集中 v 匹配的近似类型。</p>
<p>一种解决这种情况的办法是允许在 type switch 中写近似类型，像 <code>case ~float32:</code>。这样这个case 将匹配任何底层类型是 float32 的类型。这是有意义的，并且有用，即使在泛型函数这外的 type switch 中也一样。</p>
<h4 id="无法表达可转换性"><a href="#无法表达可转换性" class="headerlink" title="无法表达可转换性"></a>无法表达可转换性</h4><p>该设计无法表达两个不同类型的转换性。例如，无法写这样的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy 从 src 拷贝值到 dst，随时转换它们。</span></span><br><span class="line"><span class="comment">// 它返回复制的项目数量，它是 dst 和 src 的长度的最小值。</span></span><br><span class="line"><span class="comment">// 这个实现是无效的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copy</span>[<span class="title">T1</span>, <span class="title">T2</span> <span class="title">any</span>]<span class="params">(dst []T1, src []T2)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, x := <span class="keyword">range</span> src &#123;</span><br><span class="line">		<span class="keyword">if</span> i &gt; <span class="built_in">len</span>(dst) &#123;</span><br><span class="line">			<span class="keyword">return</span> i</span><br><span class="line">		&#125;</span><br><span class="line">		dst[i] = T1(x) <span class="comment">// 无效的</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(src)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从类型 T2 转换到类型 T1 是无效的，因为对于允许转换的类型都没有约束。更糟的是，在泛型中没有办法写出这样的约束。在特殊情况下, T1 和 T2 都有有限的类型集，这个函数可以写成抑是之前讨论使用类型集来转换的那样。但是，例如，没有办法为这种情况写一个约束，让T1是接口类型并且 T2 是实现了该接口的类型。</p>
<p>值得注意的是如果 T1 是一个接口类型然后这可以写成使用转换成空接口类型并且类型断言的方式，但是当然，这不是编译时类型安全的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy 从 src 到 dst 复制值，随时转换它们。</span></span><br><span class="line"><span class="comment">// 它返回复制的项目数量，它是 dst 和 src 的长度的最小值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copy</span>[<span class="title">T1</span>, <span class="title">T2</span> <span class="title">any</span>]<span class="params">(dst []T1, src []T2)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, x := <span class="keyword">range</span> src &#123;</span><br><span class="line">		<span class="keyword">if</span> i &gt; <span class="built_in">len</span>(dst) &#123;</span><br><span class="line">			<span class="keyword">return</span> i</span><br><span class="line">		&#125;</span><br><span class="line">		dst[i] = (<span class="keyword">interface</span>&#123;&#125;)(x).(T1)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(src)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="没有参数化的方法"><a href="#没有参数化的方法" class="headerlink" title="没有参数化的方法"></a>没有参数化的方法</h4><p>该设计不允许方法声明对方法特定的类型参数。接受者可能有类型参数，但是方法不能添加任何的类型参数。</p>
<p>在 Go 中，方法的主要角色之一就是允许类型实现接口。目前尚不清楚是否可以合理地允许参数化方法实现接口。例如，思考这个代码，对参数化方法使用了明显的语法。这个代码使用了多个包，使用问题更清楚。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> p1</span><br><span class="line"></span><br><span class="line"><span class="comment">// S 是一个拥有参数化方法 Identity 的类型。</span></span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Identity 是一个简单的对于所有类型都有效的相等方法。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(S)</span> <span class="title">Identity</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(v T)</span> <span class="title">T</span></span> &#123; <span class="keyword">return</span> v &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> p2</span><br><span class="line"></span><br><span class="line"><span class="comment">// HasIdentity 是一个接口匹配任何有有参数化 Identity 方法的类型。</span></span><br><span class="line"><span class="keyword">type</span> HasIdentity <span class="keyword">interface</span> &#123;</span><br><span class="line">	Identity[T any](T) T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> p3</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"p2"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CheckIdentity 检查 Identity 方法是否存在。</span></span><br><span class="line"><span class="comment">// 注意虽然这个方法调用了一个参数化方法，</span></span><br><span class="line"><span class="comment">// 这个函数不是它自己的参数化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CheckIdentity</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> vi, ok := v.(p2.HasIdentity); ok &#123;</span><br><span class="line">		<span class="keyword">if</span> got := vi.Identity[<span class="keyword">int</span>](<span class="number">0</span>); got != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(got)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> p4</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"p1"</span></span><br><span class="line">	<span class="string">"p3"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// CheckSIdentity 传一个 S 值给 CheckIdentity。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CheckSIdentity</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p3.CheckIdentity(p1.S&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们有一个带有参数化方法的类型 p1.S 和一个也有参数化方法的类型 p2.HasIdentity。p1.S 实现了 p2.HasIdentity。所以，函数 p3.CheckIdentity 可以用 int 参数调用 vi.Identity，在 p4.CheckSIdentity 的调用中将会调用 p1.S.Identity[int]。但是包 p3 不知道关于 p1.S 类型的任何事。可能在程序的别的地方没有其它调用 p1.S.Identity 的地方。我们需要在别的地方实例化 p1.S.Identity[int], 但是怎么做到呢？</p>
<p>我们可以在链接时实例化它，但是一般情况下这需要链接器遍历完整的程序调用图来决定可能传给 CheckIdentity 的类型集。并且当反射类型被调用的时候，遍历也不能满足一般情况，因为径向可能基于用户输入的字符串来录找方法。所以通常在链接器中实例化参数化方法可能震怒为每个可能的类型参数实例化每个参数化方法，这似乎是站不住脚的。</p>
<p>或者，我们可以在运行时实例化它。一般来说这意味着使用某种 JIT，或编译代码以使用某种反射方法。这里每种方法非常复杂难以实现，并且在运行时会非常慢。</p>
<p>或者，我们可以决定参数化方法实际上不实现接口，但是这样对于我们为什么需要这个方法就不够清楚。如果我们不考虑接口，任何参数化方法可以被当作一个参数化函数实现。</p>
<p>因此，虽然参数化方法乍一看很有用，但是我们必须决定它们的含义以及如何实现它。</p>
<h4 id="没有办法要求指针方法"><a href="#没有办法要求指针方法" class="headerlink" title="没有办法要求指针方法"></a>没有办法要求指针方法</h4><p>在一此情况下，参数化函数是自然编写的，因为它总是可寻址值的方法。例如，当在切片中每个元素上调用方法，这就会发生。在这种情况下，该函数只要求方法在切片元素类型指针的方法集中。这个设计中描述的类型约束无法编写这样的要求。</p>
<p>例如，思考一个我之前展示过的例子中的 Stringify 的变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stringify2 在 s 的每个元素上调用 String 方法，并返回结果。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stringify2</span>[<span class="title">T</span> <span class="title">Stringer</span>]<span class="params">(s []T)</span> <span class="params">(ret []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</span><br><span class="line">		ret = <span class="built_in">append</span>(ret, s[i].String())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设我们有一个 []bytes.Buffer 并且我们想要把它转换成 []string。这里的 Stringify2 函数并不能帮我们做到。我们想要写一个Stringify2[bytes.Buffer]，但是我们不能，因为 bytes.Buffer 没有 String 方法。有 String 方法的类型是 <code>*bytes.Buffer</code>，但是我们只有 <code>[]bytes.Buffer</code>。</p>
<p>在上面指针方法例子中我们讨论过类似的情况。在那个例子中我们使用约束类型推断来简化问题。这里这样行不通，因为 Stringify2 实际并不关心调用一个指针方法。它只是想要一个有 String 方法的类型，并且如果方法只在指针方法集中，不在值方法集中也可以。但是我们也想要接受方法在值方法集中的情况，例如，如果我们真的有一个 <code>[]*bytes.Buffer</code>。</p>
<p>我们需要一种方式来说明类型约束适用于指针方法集还是值方法集。函数主体只需要调用该类型的可寻址值方法。</p>
<p>这个问题在实践中多久被解决还不清楚。</p>
<h4 id="浮点数和复数之间没有关联"><a href="#浮点数和复数之间没有关联" class="headerlink" title="浮点数和复数之间没有关联"></a>浮点数和复数之间没有关联</h4><p>约束类型推断让我们给切片类型的元素一个名字，并且应用其它类似类型分解。然而，没有方法关联浮点类型和复合类型。例如，使用这个设计没有办法与一个预定义的实数，虚数，或复合函数。没有办法说“如果参数类型是 complex64，那么结构类型是 float32。”</p>
<p>一个可能的方法是允许real(T)作为类型约束，意思是“与复合类型T关联的浮点类型”。类似地，complex(T)将表示“与浮点类型T关联的复合类型”。约束类型推断将简化调用站点。但是，这与其他类型约束不同。</p>
<h3 id="放弃的想法"><a href="#放弃的想法" class="headerlink" title="放弃的想法"></a>放弃的想法</h3><p>这个设计不是完善的，可能有改进的方法。这就是说，我们已经详细考虑了许多想法。本节列出了其中的一些想法，希望有助于减少重复讨论。这些想法以常见问题解答的形式呈现。</p>
<h4 id="contract-发生了什么"><a href="#contract-发生了什么" class="headerlink" title="contract 发生了什么"></a>contract 发生了什么</h4><p>较早的泛型设计草案使用称为合同的新语言结构实现了约束。类型集只出现在全同中，而不出现在接口类型中。然而很多人很难理解合约和接口类型之间的区别。事实证明，合约可以表示为一组相应的接口；没有合同就没有表达能力的损失。我们决定简化只使用接口类型的方法。</p>
<h4 id="为什么不用方法集而使用类型集？"><a href="#为什么不用方法集而使用类型集？" class="headerlink" title="为什么不用方法集而使用类型集？"></a>为什么不用方法集而使用类型集？</h4><p>类型集是神秘的。为什么不为所有操作符写方法呢？</p>
<p>允许操作符作为方法名字是可能的，导致方法像<code>+(T) T</code>。不幸地，这是不满足的。我们需要一些机制来描述匹配任何整数类型的类型，对于像移位<code>&lt;&lt;(integer) T</code>和索引<code>[](integer) T</code>的操作，它们不只限制于单独的 int 类型。对于像 <code>==(T)</code> 的操作，我们也需要未知类型的布尔类型。对于像转换的操作，我们需要引入新的记号，或者表示它可能跨域一个类型，这可能需要一些新的语法。我们需要一些机制来描述无类型常量的有效值。我们必须考虑是否支持<code>&lt;(T) bool</code>是否意味着泛型函数也可以使用<code>&lt;=</code>，同样是否支持<code>+(T) T</code>意味洋函数可以使用<code>++</code>。使用这种方式生效也是可能的，但是它不直观。使用这个设计的方式好像更简单，并且只依赖一个新语法构造(类型集) 和一个新名字(comparable)。</p>
<h4 id="为什么不在包上加类型参数？"><a href="#为什么不在包上加类型参数？" class="headerlink" title="为什么不在包上加类型参数？"></a>为什么不在包上加类型参数？</h4><p>我们广泛地调查这个。当你想要写一个 list 包的时候，并且你想这个包包含一个 Transform 函数，它可以把一个类型的 List 转换成另一个类型的 List，这个时候会有问题。在一个包的实例中的一个函数，返回一个类型，它需要同一个包的不同的实例，这会很奇怪。</p>
<p>包边界与类型定义也会让人很迷惑。没有特别的理由认为泛型类型的使用会整齐的分解包。有时它们会，有时间它们不会。</p>
<h4 id="为什么不像-C-和-Java-一样使用-F-lt-T-gt-这样的语法"><a href="#为什么不像-C-和-Java-一样使用-F-lt-T-gt-这样的语法" class="headerlink" title="为什么不像 C++ 和 Java 一样使用 F&lt;T&gt; 这样的语法?"></a>为什么不像 C++ 和 Java 一样使用 <code>F&lt;T&gt;</code> 这样的语法?</h4><p>当解析函数中的代码时，比如 <code>v:= F&lt;T&gt;</code>，在找到<code>&lt;</code>的点，我们是寻找一个类型实例还是寻找一个使用<code>&lt;</code>操作符的表达工呢？就会模糊不清。在没有类荆信息的时候，这很难解。</p>
<p>例如，思考一个像这样的语句</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = w &lt; x, y &gt; (z)</span><br></pre></td></tr></table></figure>
<p>没有类型信息，无法决定等号右边是一对表达式（<code>w &lt; x and y &gt; (z)</code>），还是泛型函数实例化并且调用它返回两个结果值（<code>(w&lt;x, y&gt;)(z)</code>）。</p>
<p>Go 的一个关键设计就是没有类型信息解析是可能的，当泛型使用尖括号时，这好像是不可能的。</p>
<h4 id="为什么不使用-F-T-语法？"><a href="#为什么不使用-F-T-语法？" class="headerlink" title="为什么不使用 F(T) 语法？"></a>为什么不使用 F(T) 语法？</h4><p>这个设计的早期版本使用这个语法。这是可以的，不过它引入几个解析歧义。比如，当写<code>var f func(x(T))</code>，不清楚该类型是具有实例化类型x(T) 的单个未命名的参数的函数，还是具有名为 x 的参数的函数类型(T)（通常写为 func(x T)，但是在这种情况下使用带括号的类型）。</p>
<p>也有其它的歧义。对于<code>[]T(v1)</code>和<code>[]T(v2){}</code>，在开括号的位置，我们不知道这是一个类型转换（v1的值转换成<code>[]T</code>类型）还是一个类型字面量（它的类型是实例化的<code>T(v2)</code>）。对于<code>interface { M(T) }</code>，我们不知道这是一个拥有方法M的接口还是一个拥有一个内嵌实例化接口M(T)的接口。这些歧义可以解决，添加更多的括号，但是很笨拙。</p>
<p>也有一些人对像<code>func F(T any)(v T)(r1, r2 T)</code>的声明或像<code>F(int)(1)</code>调用中涉及的括号数量所困扰。</p>
<h4 id="为什么不使用F«T»"><a href="#为什么不使用F«T»" class="headerlink" title="为什么不使用F«T»?"></a>为什么不使用<code>F«T»</code>?</h4><p>我们考虑过它但是我们不能让自己需要非ASCII字符。</p>
<h4 id="为什么不把-constraints-定义在-builtin-包中？"><a href="#为什么不把-constraints-定义在-builtin-包中？" class="headerlink" title="为什么不把 constraints 定义在 builtin 包中？"></a>为什么不把 constraints 定义在 builtin 包中？</h4><p>不是写出类型集，而是使用像 constraints.Arithmetic 和 constraints.Comparable 的名字。</p>
<p>列出所有可能组合的类型集非常长。它还引入一组新名称，不仅是通用代码的编写者，更重要的是，读者，必须记住。这个设计致力的一个目标就是尽可能的少引入新的名字。在这个设计中我们只引入两个新的预定义名字，comparable 和 any。</p>
<p>我们希望如果人们发现这样有用的名字，我们可以引入一个 constraints 包来定义这些名字，这些名称可以被其他类型和函数使用并嵌入到其他约束中。这将在标准库中定义最有用的名字，同时让程序员可以灵活地在适当的情况下使用其他类型组合。</p>
<h4 id="为什么不允许对类型是类型参数的值进行类型断言？"><a href="#为什么不允许对类型是类型参数的值进行类型断言？" class="headerlink" title="为什么不允许对类型是类型参数的值进行类型断言？"></a>为什么不允许对类型是类型参数的值进行类型断言？</h4><p>在这个设计的早期版本中，我们允许对类型是类型参数或它的类型是基于类型参数的变量使用类型断言和类型 switch。我们移除这个功能是因为把任何类型转换成空接口类型总是可能的，然后对它使用类型断言或类型 switch。此外，有时令人困惑的是，在具有使用近似元素的类型集的约束中，类型断言或类型switch 将使用实际的类型参数，而不是类型参数的底层类型（差异在关于识别匹配的预声明类型的部分中）。</p>
<h4 id="跟Java相比"><a href="#跟Java相比" class="headerlink" title="跟Java相比"></a>跟Java相比</h4><p>大多数关于Java泛型的抱怨都是围绕类型擦除的。这个设计没有类型擦除。泛型类型的反射信息包含完全的编译时类型信息。</p>
<p>在Java中的类型通配符(<code>List&lt;? extends Number&gt;, List&lt;? super Number&gt;</code>) 实现了协变和逆变。Go缺少这些概念，这使得泛型更简单。</p>
<h4 id="跟C-相比"><a href="#跟C-相比" class="headerlink" title="跟C++相比"></a>跟C++相比</h4><p>C++模板不对类型参数强加任何限制（除非概念提案被采纳）。这意味着更改模板代码可能会意外地破坏遥远的实例化。也意味着错误信息只会在实例化时才会报，并且可能被尝试嵌套且难以明白。这个设计通过强制和显式约束避免了这些问题。</p>
<p>C++ 支持模板元编程，可以将其视为在编译时使用与非模板C++完全不同的语法完成的普通编程。这个设计没有类似的特性。这节省了相当多的复杂性，同时损失了一些能力和运行时效率。</p>
<p>C++ 使用两阶段名字查找，一些名字是在模板定义期间被找到的，一些名字是在模板实例化时找到的。这个设计中所有名字都是在它们被写的地方查找的。</p>
<p>在实践中，所有C++ 编译器在它实例化的地方编译每个模板。这可能拖慢编译时间。这个设计提供了如何处理泛型函数编译的灵活性。</p>
<h4 id="跟-Rust-相比"><a href="#跟-Rust-相比" class="headerlink" title="跟 Rust 相比"></a>跟 Rust 相比</h4><p>在这个设计中描述的泛型跟 Rust 的泛型很像。</p>
<p>一个不同是在Rust中 trait bound 和类型的关系必须被明确定义，在定义 trait bound 的 crate 中或在定义类型的 crate 中。在 Go 术语中，这意味着我们必须在某个地方声明一个类型是否满足约束。就像Go 类型可以不需要明确的声明就满足 Go 接口，在这个设计中 Go 类型参数可以不用显式声明就可以满足约束。</p>
<p>这个设计使用类型集的地方，Rust 标准库为 comparison 等操作定义了标准 traits。这些标准 traits 由 Rust 的原始类型自动实现，也可以由用户定义的类型实现。Rust 提供了一个相当广泛的特征列表，至少 34 个，涵盖了所有的操作符。</p>
<p>Rust 支持方法上的类型参数，这个设计不支持。</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>下面是这个设计可以怎么使用的例子。这旨在解决人们创建与 Go 缺少泛型有关的用户体验报告的特定领域。</p>
<h2 id="Map-Reduce-Filter"><a href="#Map-Reduce-Filter" class="headerlink" title="Map/Reduce/Filter"></a>Map/Reduce/Filter</h2><p>这是一个如何写 map, reduce, 和 filter 的例子。这些函数旨在对应于 Lisp, Python, Java 等中类似的函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package slices 实现了各种 slice 算法。</span></span><br><span class="line"><span class="keyword">package</span> slices</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map 使用映射函数把 []T1 转换成 []T2。</span></span><br><span class="line"><span class="comment">// 这个函数有两个参数，T1和T2.</span></span><br><span class="line"><span class="comment">// 对任何List 都有效</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Map</span>[<span class="title">T1</span>, <span class="title">T2</span> <span class="title">any</span>]<span class="params">(s []T1, f <span class="keyword">func</span>(T1)</span> <span class="title">T2</span>) []<span class="title">T2</span></span> &#123;</span><br><span class="line">	r := <span class="built_in">make</span>([]T2, <span class="built_in">len</span>(s))</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		r[i] = f(v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reduce 使用减少函数把 []T1 减少到单个值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reduce</span>[<span class="title">T1</span>, <span class="title">T2</span> <span class="title">any</span>]<span class="params">(s []T1, initializer T2, f <span class="keyword">func</span>(T2, T1)</span> <span class="title">T2</span>) <span class="title">T2</span></span> &#123;</span><br><span class="line">	r := initializer</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		r = f(r, v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Filter 使用过滤函数从 slice 中过滤值</span></span><br><span class="line"><span class="comment">// 它返回一个新的 slice, 只包含 s 中元素且 f 返回 true 的元素.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Filter</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(s []T, f <span class="keyword">func</span>(T)</span> <span class="title">bool</span>) []<span class="title">T</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> r []T</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		<span class="keyword">if</span> f(v) &#123;</span><br><span class="line">			r = <span class="built_in">append</span>(r, v)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是这些函数的一些调用例子。类型推断被用于根据非类型参数的类型确实类型参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">floats := slices.Map(s, <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123; <span class="keyword">return</span> <span class="keyword">float64</span>(i) &#125;)</span><br><span class="line"><span class="comment">// 现在floats 是 []float64&#123;1.0, 2.0, 3.0&#125;.</span></span><br><span class="line"></span><br><span class="line">sum := slices.Reduce(s, <span class="number">0</span>, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> i + j &#125;)</span><br><span class="line"><span class="comment">// 现在 sum 是 6.</span></span><br><span class="line"></span><br><span class="line">evens := slices.Filter(s, <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> i%<span class="number">2</span> == <span class="number">0</span> &#125;)</span><br><span class="line"><span class="comment">// 现在 evens 是 []int&#123;2&#125;.</span></span><br></pre></td></tr></table></figure>
<h2 id="Map-keys"><a href="#Map-keys" class="headerlink" title="Map keys"></a>Map keys</h2><p>这是如何得到任意一个 map 的 keys 切片</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package maps 提供了对任何 map 类型都有效的泛型函数。</span></span><br><span class="line"><span class="keyword">package</span> maps</span><br><span class="line"></span><br><span class="line"><span class="comment">// Keys 返回 map m 的所有键, 以切片形式。</span></span><br><span class="line"><span class="comment">// 键以未定义顺序的方式返回。</span></span><br><span class="line"><span class="comment">// 这个函数有两个类型参数，K和V。</span></span><br><span class="line"><span class="comment">// Map 键必须是 comparable, 所以 key 有预定义的约束 comparable。Map值可以是任意类型。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Keys</span>[<span class="title">K</span> <span class="title">comparable</span>, <span class="title">V</span> <span class="title">any</span>]<span class="params">(m <span class="keyword">map</span>[K]V)</span> []<span class="title">K</span></span> &#123;</span><br><span class="line">	r := <span class="built_in">make</span>([]K, <span class="number">0</span>, <span class="built_in">len</span>(m))</span><br><span class="line">	<span class="keyword">for</span> k := <span class="keyword">range</span> m &#123;</span><br><span class="line">		r = <span class="built_in">append</span>(r, k)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>典型使用情况下，map 键值类型都将被推断出来。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k := maps.Keys(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>:<span class="number">2</span>, <span class="number">2</span>:<span class="number">4</span>&#125;)</span><br><span class="line"><span class="comment">// 现在 k 是 []int&#123;1, 2&#125; 或者 []int&#123;2, 1&#125;.</span></span><br></pre></td></tr></table></figure>
<h2 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h2><p>很多人要求扩展或缩减Go的内置地图类型以支持集合类型。这是一个集合类型的类型安全袜，尽管它使用方法而不是像[]这样的运行符。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package sets 实现了任何可比较类型的集合</span></span><br><span class="line"><span class="keyword">package</span> sets</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set 是值的集合</span></span><br><span class="line"><span class="keyword">type</span> Set[T comparable] <span class="keyword">map</span>[T]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make 返回一些元素类型的集合</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Make</span>[<span class="title">T</span> <span class="title">comparable</span>]<span class="params">()</span> <span class="title">Set</span>[<span class="title">T</span>]</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">make</span>(Set[T])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 添加 v 到集合 s 中</span></span><br><span class="line"><span class="comment">// If v is already in s this has no effect.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Set[T])</span> <span class="title">Add</span><span class="params">(v T)</span></span> &#123;</span><br><span class="line">	s[v] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete 从集合s中移除 v</span></span><br><span class="line"><span class="comment">// 如果 v 不在 s 中，没有任何效果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Set[T])</span> <span class="title">Delete</span><span class="params">(v T)</span></span> &#123;</span><br><span class="line">	<span class="built_in">delete</span>(s, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Contains 报告 v 是否在s中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Set[T])</span> <span class="title">Contains</span><span class="params">(v T)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	_, ok := s[v]</span><br><span class="line">	<span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Len 报告s中元素的数量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Set[T])</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterate 在s中每个元素上调用f</span></span><br><span class="line"><span class="comment">// 对f调用 Delete 方法也可以</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Set[T])</span> <span class="title">Iterate</span><span class="params">(f <span class="keyword">func</span>(T)</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		f(v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个int集合</span></span><br><span class="line"><span class="comment">// 我们把int当作类型参数</span></span><br><span class="line"><span class="comment">// 然后我们写(), 因为Make没有任何普通参数</span></span><br><span class="line"><span class="comment">// 我们必须给Make传明确的类型参数。</span></span><br><span class="line"><span class="comment">// 函数参数类型推断不生效，因为Make的类型参数只作为结果类型参数。</span></span><br><span class="line">s := sets.Make[<span class="keyword">int</span>]()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 把 1 添加到 s 中</span></span><br><span class="line">s.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 s 不包含2</span></span><br><span class="line"><span class="keyword">if</span> s.Contains(<span class="number">2</span>) &#123; <span class="built_in">panic</span>(<span class="string">"unexpected 2"</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>这个例子展示了如何使用这个设计来为一个存在的API提供一下编译时类型安全的包装</p>
<h2 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h2><p>在引入 sort.Slice 之前，一个常见的报怨是需要样板定义才能使用 sort.Sort。通过这种设计，我们可以在 sort 包中添加如下内容。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ordered 是匹配所有排序类型的类型约束。</span></span><br><span class="line"><span class="comment">// (排序类型是支持操作符的类型 &lt; &lt;= &gt;= &gt; )</span></span><br><span class="line"><span class="comment">// 实践中这个类型约束一般被定义在标准库中。</span></span><br><span class="line"><span class="keyword">type</span> Ordered <span class="keyword">interface</span> &#123;</span><br><span class="line">	~<span class="keyword">int</span> | ~<span class="keyword">int8</span> | ~<span class="keyword">int16</span> | ~<span class="keyword">int32</span> | ~<span class="keyword">int64</span> |</span><br><span class="line">		~<span class="keyword">uint</span> | ~<span class="keyword">uint8</span> | ~<span class="keyword">uint16</span> | ~<span class="keyword">uint32</span> | ~<span class="keyword">uint64</span> | ~<span class="keyword">uintptr</span> |</span><br><span class="line">		~<span class="keyword">float32</span> | ~<span class="keyword">float64</span> |</span><br><span class="line">		~<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// orderedSlice 是一个实现了 sort.Interface 的内部类型。</span></span><br><span class="line"><span class="comment">// Less 方法使用 &lt; 操作符。排序的类型约束确保T有 &lt; 操作符。</span></span><br><span class="line"><span class="keyword">type</span> orderedSlice[T Ordered] []T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s orderedSlice[T])</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(s) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s orderedSlice[T])</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> s[i] &lt; s[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s orderedSlice[T])</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; s[i], s[j] = s[j], s[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OrderedSlice 以升序排序切片s.</span></span><br><span class="line"><span class="comment">// s的元素必须是使用 &lt; 操作符排序的。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OrderedSlice</span>[<span class="title">T</span> <span class="title">Ordered</span>]<span class="params">(s []T)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 把 s 转换成类型 orderedSlice[T].</span></span><br><span class="line">	<span class="comment">// 因为 s 是 []T, 并且 orderedSlice[T] 定义为 []T,</span></span><br><span class="line">	<span class="comment">// 这个转换是允许的。</span></span><br><span class="line">	<span class="comment">// orderedSlice[T] 实现了sort.Interface,</span></span><br><span class="line">	<span class="comment">// 所以可以把结果传给sort.Sort.</span></span><br><span class="line">	<span class="comment">// 元素将被用 &lt; 操作符排序。</span></span><br><span class="line">	sort.Sort(orderedSlice[T](s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们可以这样写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="keyword">int32</span>&#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>&#125;</span><br><span class="line">sort.OrderedSlice(s1)</span><br><span class="line"><span class="comment">// 现在 s1 是 []int32&#123;2, 3, 5&#125;</span></span><br><span class="line"></span><br><span class="line">s2 := []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"c"</span>, <span class="string">"b"</span>&#125;)</span><br><span class="line">sort.OrderedSlice(s2)</span><br><span class="line"><span class="comment">// 现在 s2 是 []string&#123;"a", "b", "c"&#125;</span></span><br></pre></td></tr></table></figure>
<p>使用一样的行数，我们可以添加一个使用 comparsion 函数排序的函数，跟 sort.Slice 类似，但是写函数接收值而不是切片索引。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sliceFn 是一个实现了 sort.Interface 的内部类型。</span></span><br><span class="line"><span class="comment">// Less 方法调用 cmp 字段。</span></span><br><span class="line"><span class="keyword">type</span> sliceFn[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">	s   []T</span><br><span class="line">	cmp <span class="function"><span class="keyword">func</span><span class="params">(T, T)</span> <span class="title">bool</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s sliceFn[T])</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(s.s) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s sliceFn[T])</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> s.cmp(s.s[i], s.s[j]) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s sliceFn[T])</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; s.s[i], s.s[j] = s.s[j], s.s[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SliceFn 根据函数cmp排序切片s</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SliceFn</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(s []T, cmp <span class="keyword">func</span>(T, T)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line">	sort.Sort(sliceFn[T]&#123;s, cmp&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用这个的例子是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []*Person</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">sort.SliceFn(s, <span class="function"><span class="keyword">func</span><span class="params">(p1, p2 *Person)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> p1.Name &lt; p2.Name &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h2><p>许多简单一般目标的 channel 函数是从来不写的，因为它们必须使用反射并且调用者必须对结果使用类型断言。用这个设计，它们可以直白的这么写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package chans 实现了各位 channel 算法。</span></span><br><span class="line"><span class="keyword">package</span> chans</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"runtime"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Drain 耗尽channel 中的元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Drain</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(c &lt;-<span class="keyword">chan</span> T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">range</span> c &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Merge 合并两个同样元素类型的 channel 为一个单独的channel.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Merge</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(c1, c2 &lt;-<span class="keyword">chan</span> T)</span> &lt;-<span class="title">chan</span> <span class="title">T</span></span> &#123;</span><br><span class="line">	r := <span class="built_in">make</span>(<span class="keyword">chan</span> T)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(c1, c2 &lt;-<span class="keyword">chan</span> T, r <span class="keyword">chan</span>&lt;- T)</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(r)</span><br><span class="line">		<span class="keyword">for</span> c1 != <span class="literal">nil</span> || c2 != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> v1, ok := &lt;-c1:</span><br><span class="line">				<span class="keyword">if</span> ok &#123;</span><br><span class="line">					r &lt;- v1</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					c1 = <span class="literal">nil</span></span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">case</span> v2, ok := &lt;-c2:</span><br><span class="line">				<span class="keyword">if</span> ok &#123;</span><br><span class="line">					r &lt;- v2</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					c2 = <span class="literal">nil</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(c1, c2, r)</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ranger 提供了一个当接收者停止读它们时，便利的退出发送值的goroutine 的方式.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Ranger 返回一个 Sender 和 Recevier。Receiver 提供了 Next 方法用于接收值。</span></span><br><span class="line"><span class="comment">// Sender 提供了一个Send方法用于发送值和一个 Close方法用于停止发送值。</span></span><br><span class="line"><span class="comment">// Next 文件指示 Sender 何时关闭，Send 方法指示 Receiver 何时释放。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Ranger</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">()</span> <span class="params">(*Sender[T], *Receiver[T])</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> T)</span><br><span class="line">	d := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	s := &amp;Sender[T]&#123;values: c, done: d&#125;</span><br><span class="line">	r := &amp;Receiver[T]&#123;values: c, done: d&#125;</span><br><span class="line">	<span class="comment">// receiver 的 finalizer 将会告诉发送者接收者是否停止监听了。</span></span><br><span class="line">	runtime.SetFinalizer(r, r.finalize)</span><br><span class="line">	<span class="keyword">return</span> s, r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sender 用于发送值给接收者</span></span><br><span class="line"><span class="keyword">type</span> Sender[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">	values <span class="keyword">chan</span>&lt;- T</span><br><span class="line">	done   &lt;-<span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send 发送值给接收者。它报告是否可以发送更多值；如果它返回false, 则该值没有发送。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Sender[T])</span> <span class="title">Send</span><span class="params">(v T)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> s.values &lt;- v:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-s.done:</span><br><span class="line">		<span class="comment">// 接收者已经停止监听了。</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close 告诉接收者不再有值到达了。Close 关闭后，Sender 不能再使用了。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Sender[T])</span> <span class="title">Close</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">close</span>(s.values)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Receiver 从 Sender 接收值</span></span><br><span class="line"><span class="keyword">type</span> Receiver[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">	values &lt;-<span class="keyword">chan</span> T</span><br><span class="line">	done  <span class="keyword">chan</span>&lt;- <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next 返回下一个来自 channel 的值。bool 结果报告值是否是有效的。如果值是无效的，</span></span><br><span class="line"><span class="comment">// Sender已经关闭了并且再没有值会到达了。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Receiver[T])</span> <span class="title">Next</span><span class="params">()</span> <span class="params">(T, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	v, ok := &lt;-r.values</span><br><span class="line">	<span class="keyword">return</span> v, ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// finalize 是一个接收者的终结。</span></span><br><span class="line"><span class="comment">// 它告诉发送者接收者停止监听了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Receiver[T])</span> <span class="title">finalize</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">close</span>(r.done)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在下一个部分，有一个使用这个函数的例子。</p>
<h2 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a>Containers</h2><p>一个对Go泛型的频繁的请求是写编译时类型安全容器的能力。这个设计使对现有的容器写编译时类型安全的包装器非常容易。我们不写这样的例子。这个设计也使编写不使用装箱的编译时类型安全的容器更容易。</p>
<p>这是一个以二叉树实现的排序map的例子。它的实现细节并不太重要。重要的是：</p>
<ul>
<li>代码是用纯正的go风格编写的，使用需要的键值类型。</li>
<li>键和值是直接以树的结点存储的，不是使用指针，没有装条成interface 值。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package orderedmaps 提供了一个排序的 map, 二叉树实现。</span></span><br><span class="line"><span class="keyword">package</span> orderedmaps</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"chans"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map 是一个排序的map</span></span><br><span class="line"><span class="keyword">type</span> Map[K, V any] <span class="keyword">struct</span> &#123;</span><br><span class="line">	root    *node[K, V]</span><br><span class="line">	compare <span class="function"><span class="keyword">func</span><span class="params">(K, K)</span> <span class="title">int</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// node 是二叉树中结点的类型</span></span><br><span class="line"><span class="keyword">type</span> node[K, V any] <span class="keyword">struct</span> &#123;</span><br><span class="line">	k           K</span><br><span class="line">	v           V</span><br><span class="line">	left, right *node[K, V]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New 返回一个新的map.</span></span><br><span class="line"><span class="comment">// 由于类型参数 V 只用于结果，</span></span><br><span class="line"><span class="comment">// 类型推断不生效，调用 New 必须传明确的类型参数。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span>[<span class="title">K</span>, <span class="title">V</span> <span class="title">any</span>]<span class="params">(compare <span class="keyword">func</span>(K, K)</span> <span class="title">int</span>) *<span class="title">Map</span>[<span class="title">K</span>, <span class="title">V</span>]</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Map[K, V]&#123;compare: compare&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// find 在map寻找k, 并且返回一个指针，指向拥有k的节点，或者一个指针，指向这样的节点</span></span><br><span class="line"><span class="comment">// 将会在的位置。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map[K, V])</span> <span class="title">find</span><span class="params">(k K)</span> **<span class="title">node</span>[<span class="title">K</span>, <span class="title">V</span>]</span> &#123;</span><br><span class="line">	pn := &amp;m.root</span><br><span class="line">	<span class="keyword">for</span> *pn != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> cmp := m.compare(k, (*pn).k); &#123;</span><br><span class="line">		<span class="keyword">case</span> cmp &lt; <span class="number">0</span>:</span><br><span class="line">			pn = &amp;(*pn).left</span><br><span class="line">		<span class="keyword">case</span> cmp &gt; <span class="number">0</span>:</span><br><span class="line">			pn = &amp;(*pn).right</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> pn</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert 插入新的键/值到map 中。</span></span><br><span class="line"><span class="comment">// 如果键已经存在，值将被替换。</span></span><br><span class="line"><span class="comment">// 报告这是否是一个新的键</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map[K, V])</span> <span class="title">Insert</span><span class="params">(k K, v V)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	pn := m.find(k)</span><br><span class="line">	<span class="keyword">if</span> *pn != <span class="literal">nil</span> &#123;</span><br><span class="line">		(*pn).v = v</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	*pn = &amp;node[K, V]&#123;k: k, v: v&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find 返回与键关联的值，如果不存在，返回零值。</span></span><br><span class="line"><span class="comment">// bool 结果报告key是否被发现。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map[K, V])</span> <span class="title">Find</span><span class="params">(k K)</span> <span class="params">(V, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	pn := m.find(k)</span><br><span class="line">	<span class="keyword">if</span> *pn == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> zero V <span class="comment">// 看上面关于零值的讨论。</span></span><br><span class="line">		<span class="keyword">return</span> zero, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (*pn).v, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// keyValue 是用于迭代的键值对</span></span><br><span class="line"><span class="keyword">type</span> keyValue[K, V any] <span class="keyword">struct</span> &#123;</span><br><span class="line">	k K</span><br><span class="line">	v V</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// InOrder 返回一个迭代器，它按顺序遍历map</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map[K, V])</span> <span class="title">InOrder</span><span class="params">()</span> *<span class="title">Iterator</span>[<span class="title">K</span>, <span class="title">V</span>]</span> &#123;</span><br><span class="line">	<span class="keyword">type</span> kv = keyValue[K, V] <span class="comment">// 方便的缩写</span></span><br><span class="line">	sender, receiver := chans.Ranger[kv]()</span><br><span class="line">	<span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">(*node[K, V])</span> <span class="title">bool</span></span></span><br><span class="line">	f = <span class="function"><span class="keyword">func</span><span class="params">(n *node[K, V])</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Stop 发送值, 如果 sender.Send 返回 false, </span></span><br><span class="line">		<span class="comment">// 意味着在接收端没有监听了。</span></span><br><span class="line">		<span class="keyword">return</span> f(n.left) &amp;&amp;</span><br><span class="line">			sender.Send(kv&#123;n.k, n.v&#125;) &amp;&amp;</span><br><span class="line">			f(n.right)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		f(m.root)</span><br><span class="line">		sender.Close()</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> &amp;Iterator[K, V]&#123;receiver&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterator 用于迭代map</span></span><br><span class="line"><span class="keyword">type</span> Iterator[K, V any] <span class="keyword">struct</span> &#123;</span><br><span class="line">	r *chans.Receiver[keyValue[K, V]]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next 返回下一个键值对。bool结果报告值是否是有效的。如果值是无效的，我们</span></span><br><span class="line"><span class="comment">// 到达结尾</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *Iterator[K, V])</span> <span class="title">Next</span><span class="params">()</span> <span class="params">(K, V, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	kv, ok := it.r.Next()</span><br><span class="line">	<span class="keyword">return</span> kv.k, kv.v, ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是这个看起来怎么用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"container/orderedmaps"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设m是一个 string 到 string 的有序map</span></span><br><span class="line"><span class="comment">// 使用 strings.Compare 作为比较函数。</span></span><br><span class="line"><span class="keyword">var</span> m = orderedmaps.New[<span class="keyword">string</span>, <span class="keyword">string</span>](strings.Compare)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 添加a,b 对到 m 中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	m.Insert(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Append"><a href="#Append" class="headerlink" title="Append"></a>Append</h2><p>存在预先声明的 append 函数以替换样板文件，否则需要增长切片。在将 append 添加到语言之前，在bytes 包有一个 Add 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add 追加 t 的内容到 s 的结尾，并返回结果。</span></span><br><span class="line"><span class="comment">// 如果 s 有足够的空间，它在原地扩展；否则一个新的数组被分配并返回。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(s, t []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<p>Add 追加两个<code>[]byte</code>值，返回一个新的切片。这样对于<code>[]byte</code>很好，但是如果你有一个其它类型的切片，你必须写本质上同样的代码来追加更多的值。如果这个设计当时可用，可能我们不会在语言中添加 append。相反，我们可以这样写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package slices 实现了各种的切片算法。</span></span><br><span class="line"><span class="keyword">package</span> slices</span><br><span class="line"></span><br><span class="line"><span class="comment">// Append 追加t的内容到s的结尾，并且返回结果。</span></span><br><span class="line"><span class="comment">// 如果s有足够的空间，它原地扩展，否则一个新的数据被分配，并返回。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Append</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(s []T, t ...T)</span> []<span class="title">T</span></span> &#123;</span><br><span class="line">	lens := <span class="built_in">len</span>(s)</span><br><span class="line">	tot := lens + <span class="built_in">len</span>(t)</span><br><span class="line">	<span class="keyword">if</span> tot &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"Append: cap out of range"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> tot &gt; <span class="built_in">cap</span>(s) &#123;</span><br><span class="line">		news := <span class="built_in">make</span>([]T, tot, tot + tot/<span class="number">2</span>)</span><br><span class="line">		<span class="built_in">copy</span>(news, s)</span><br><span class="line">		s = news</span><br><span class="line">	&#125;</span><br><span class="line">	s = s[:tot]</span><br><span class="line">	<span class="built_in">copy</span>(s[lens:], t)</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子使用了预先声明的copy 函数，但是这是没问题的，我们也可以写一个：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy 从t复制值到s，当切片满了就停止，返回复制的值的数量。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copy</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(s, t []T)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> ; i &lt; <span class="built_in">len</span>(s) &amp;&amp; i &lt; <span class="built_in">len</span>(t); i++ &#123;</span><br><span class="line">		s[i] = t[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些函数可以像下面这样使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := slices.Append([]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"><span class="comment">// 现在 s 是 []int&#123;1, 2, 3, 4, 5, 6&#125;.</span></span><br><span class="line">slices.Copy(s[<span class="number">3</span>:], []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;)</span><br><span class="line"><span class="comment">// 现在 s 是 []int&#123;1, 2, 3, 7, 8, 9&#125;</span></span><br></pre></td></tr></table></figure>
<p>这个代码没有实现特殊的追加或复制 string 到<code>[]byte</code>的情形，它不太可能像预先定义的函数那样高效。仍然，这个例子表明，使用这种设计将允许一次通用地编写追加和复制，而不需要任何额外的特殊语言特性。</p>
<h2 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h2><p>在 Go 的体验报告中，Sammer Ajmani 描述了一个指标实现。每个指标都有一个值和一个或多个字段。字段有不同的类型。定义指标 需要指定字段的类型。Add 方法将字段类型作为参数，并记录该字段集的一个实例。C++实现使用可变参数模板。Java实现包括类型名字中的字段数。C++和Java实现都提供了编译时类型安全的 Add 方法。</p>
<p>以下是如何使用此设计通过编译时类型安全的 Add 方法在 Go 中提供类似的功能。 因为不支持可变数量的类型参数，所以我们必须为不同数量的参数使用不同的名称，就像在 Java 中一样。 此实现仅适用于可比较的类型。 更复杂的实现可以接受比较函数来处理任意类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package metrics 提供了泛型的机制来计算不同值的指标</span></span><br><span class="line"><span class="keyword">package</span> metrics</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Metric1 累加单个值的指标。</span></span><br><span class="line"><span class="keyword">type</span> Metric1[T comparable] <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu sync.Mutex</span><br><span class="line">	m  <span class="keyword">map</span>[T]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 增加值的实例。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Metric1[T])</span> <span class="title">Add</span><span class="params">(v T)</span></span> &#123;</span><br><span class="line">	m.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> m.m == <span class="literal">nil</span> &#123;</span><br><span class="line">		m.m = <span class="built_in">make</span>(<span class="keyword">map</span>[T]<span class="keyword">int</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	m.m[v]++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// key2 是被 Metric2 使用的内部类型。</span></span><br><span class="line"><span class="keyword">type</span> key2[T1, T2 comparable] <span class="keyword">struct</span> &#123;</span><br><span class="line">	f1 T1</span><br><span class="line">	f2 T2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Metric2 累加一对值的指标。</span></span><br><span class="line"><span class="keyword">type</span> Metric2[T1, T2 comparable] <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu sync.Mutex</span><br><span class="line">	m  <span class="keyword">map</span>[key2[T1, T2]]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add adds an instance of a value pair.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Metric2[T1, T2])</span> <span class="title">Add</span><span class="params">(v1 T1, v2 T2)</span></span> &#123;</span><br><span class="line">	m.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> m.m == <span class="literal">nil</span> &#123;</span><br><span class="line">		m.m = <span class="built_in">make</span>(<span class="keyword">map</span>[key2[T1, T2]]<span class="keyword">int</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	m.m[key2[T1, T2]&#123;v1, v2&#125;]++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// key3 是被 Metric3 使用的内部类型。</span></span><br><span class="line"><span class="keyword">type</span> key3[T1, T2, T3 comparable] <span class="keyword">struct</span> &#123;</span><br><span class="line">	f1 T1</span><br><span class="line">	f2 T2</span><br><span class="line">	f3 T3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Metric3 累加三个值的指标。</span></span><br><span class="line"><span class="keyword">type</span> Metric3[T1, T2, T3 comparable] <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu sync.Mutex</span><br><span class="line">	m  <span class="keyword">map</span>[key3[T1, T2, T3]]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 增加 triplet 的实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Metric3[T1, T2, T3])</span> <span class="title">Add</span><span class="params">(v1 T1, v2 T2, v3 T3)</span></span> &#123;</span><br><span class="line">	m.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> m.m == <span class="literal">nil</span> &#123;</span><br><span class="line">		m.m = <span class="built_in">make</span>(<span class="keyword">map</span>[key3[T1, T2, T3]]<span class="keyword">int</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	m.m[key3[T1, T2, T3]&#123;v1, v2, v3&#125;]++</span><br><span class="line">    <span class="comment">//  重复最大数量的允许参数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像这样使用这个包：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"metrics"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = metrics.Metric2[<span class="keyword">string</span>, <span class="keyword">int</span>]&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">(s <span class="keyword">string</span>, i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	m.Add(s, i) <span class="comment">// 这个调用在编译时检查类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于缺乏对可变参数类型参数的支持，这个实现有一定的重复。但是，使用该软件包很容易且是类型安全的。</p>
<h2 id="List-transform"><a href="#List-transform" class="headerlink" title="List transform"></a>List transform</h2><p>虽然切片是高效且容易使用，但在某些情况下链表是合适的。此示例主要展示了将一种类型的链表转换为另一种类型，作为使用相同泛型类型的不同实例化的示例。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package lists 提供了一任何类型的链表</span></span><br><span class="line"><span class="keyword">package</span> lists</span><br><span class="line"></span><br><span class="line"><span class="comment">// List 是一个链表</span></span><br><span class="line"><span class="keyword">type</span> List[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">	head, tail *element[T]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// element 是链表的一个记录</span></span><br><span class="line"><span class="keyword">type</span> element[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">	next *element[T]</span><br><span class="line">	val  T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Push 追加元素到链表的结尾</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lst *List[T])</span> <span class="title">Push</span><span class="params">(v T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> lst.tail == <span class="literal">nil</span> &#123;</span><br><span class="line">		lst.head = &amp;element[T]&#123;val: v&#125;</span><br><span class="line">		lst.tail = lst.head</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		lst.tail.next = &amp;element[T]&#123;val: v&#125;</span><br><span class="line">		lst.tail = lst.tail.next</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterator 遍历链表</span></span><br><span class="line"><span class="keyword">type</span> Iterator[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">	next **element[T]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Range 返回一个 Iterator 指向链表的开头</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lst *List[T])</span> <span class="title">Range</span><span class="params">()</span> *<span class="title">Iterator</span>[<span class="title">T</span>]</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Iterator[T]&#123;next: &amp;lst.head&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next 移动迭代器</span></span><br><span class="line"><span class="comment">// 它报告是否还有元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *Iterator[T])</span> <span class="title">Next</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> *it.next == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	it.next = &amp;(*it.next).next</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Val 返回当前元素的值。</span></span><br><span class="line"><span class="comment">// bool结果报告值是否是有效的。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *Iterator[T])</span> <span class="title">Val</span><span class="params">()</span> <span class="params">(T, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> *it.next == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> zero T</span><br><span class="line">		<span class="keyword">return</span> zero, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (*it.next).val, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Transform 运行transform 函数，返回一个新的链表。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Transform</span>[<span class="title">T1</span>, <span class="title">T2</span> <span class="title">any</span>]<span class="params">(lst *List[T1], f <span class="keyword">func</span>(T1)</span> <span class="title">T2</span>) *<span class="title">List</span>[<span class="title">T2</span>]</span> &#123;</span><br><span class="line">	ret := &amp;List[T2]&#123;&#125;</span><br><span class="line">	it := lst.Range()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> v, ok := it.Val(); ok &#123;</span><br><span class="line">			ret.Push(f(v))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !it.Next() &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="点乘"><a href="#点乘" class="headerlink" title="点乘"></a>点乘</h3><p>泛型实现了对任何数值类型都有效的点乘</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Numeric 是一个匹配任何数值类型的约束。</span></span><br><span class="line"><span class="comment">// 它可能在标准库的约束包中。</span></span><br><span class="line"><span class="keyword">type</span> Numeric <span class="keyword">interface</span> &#123;</span><br><span class="line">	~<span class="keyword">int</span> | ~<span class="keyword">int8</span> | ~<span class="keyword">int16</span> | ~<span class="keyword">int32</span> | ~<span class="keyword">int64</span> |</span><br><span class="line">		~<span class="keyword">uint</span> | ~<span class="keyword">uint8</span> | ~<span class="keyword">uint16</span> | ~<span class="keyword">uint32</span> | ~<span class="keyword">uint64</span> | ~<span class="keyword">uintptr</span> |</span><br><span class="line">		~<span class="keyword">float32</span> | ~<span class="keyword">float64</span> |</span><br><span class="line">		~<span class="keyword">complex64</span> | ~<span class="keyword">complex128</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DotProduct 返回两个切片的点乘结果。</span></span><br><span class="line"><span class="comment">// 如果两个切片不一样长，就会panic</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DotProduct</span>[<span class="title">T</span> <span class="title">Numeric</span>]<span class="params">(s1, s2 []T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s1) != <span class="built_in">len</span>(s2) &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"DotProduct: slices of unequal length"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> r T</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> s1 &#123;</span><br><span class="line">		r += s1[i] * s2[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（注意：泛型实现方法可能会影响DotProduct 是否使用 FMA，从而影响使用浮点类型时的确切结果。目前尚不清楚这是一个多大的问题，或者是否有任何方法可以解决它）</p>
<h3 id="绝对差"><a href="#绝对差" class="headerlink" title="绝对差"></a>绝对差</h3><p>通过Abs 方法计算两个数值的绝对差。这使用了定义在上个例子中同样的 Numeric 约束。</p>
<p>这个例子使用了比计算绝对差的简单情况更多的机器。它旨在展示如何将算法的公共部分分解为使用方法的代码，其中方法的确切定义可能会根据所使用的类型的种类而有所不同。</p>
<p>注意：这个例子中的代码在 Go 1.18 中不能工作。我们希望解决这个问题以使它在将来的版本中可以工作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NumericAbs 将数值类型与Abs方法匹配。</span></span><br><span class="line"><span class="keyword">type</span> NumericAbs[T any] <span class="keyword">interface</span> &#123;</span><br><span class="line">	~<span class="keyword">int</span> | ~<span class="keyword">int8</span> | ~<span class="keyword">int16</span> | ~<span class="keyword">int32</span> | ~<span class="keyword">int64</span> |</span><br><span class="line">		~<span class="keyword">uint</span> | ~<span class="keyword">uint8</span> | ~<span class="keyword">uint16</span> | ~<span class="keyword">uint32</span> | ~<span class="keyword">uint64</span> | ~<span class="keyword">uintptr</span> |</span><br><span class="line">		~<span class="keyword">float32</span> | ~<span class="keyword">float64</span> |</span><br><span class="line">		~<span class="keyword">complex64</span> | ~<span class="keyword">complex128</span></span><br><span class="line">	Abs() T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbsDifference 计算差值的绝对值 a 和 b，其中绝对值由 Abs 方法确定。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AbsDifference</span>[<span class="title">T</span> <span class="title">NumericAbs</span>[<span class="title">T</span>]]<span class="params">(a, b T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">	d := a - b</span><br><span class="line">	<span class="keyword">return</span> d.Abs()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以为不同的数值类型定义 Abs 方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OrderedNumeric 匹配支持&lt; 操作符的数据类型</span></span><br><span class="line"><span class="keyword">type</span> OrderedNumeric <span class="keyword">interface</span> &#123;</span><br><span class="line">	~<span class="keyword">int</span> | ~<span class="keyword">int8</span> | ~<span class="keyword">int16</span> | ~<span class="keyword">int32</span> | ~<span class="keyword">int64</span> |</span><br><span class="line">		~<span class="keyword">uint</span> | ~<span class="keyword">uint8</span> | ~<span class="keyword">uint16</span> | ~<span class="keyword">uint32</span> | ~<span class="keyword">uint64</span> | ~<span class="keyword">uintptr</span> |</span><br><span class="line">		~<span class="keyword">float32</span> | ~<span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Complex 匹配两个复数类型，不支持 &lt; 操作符</span></span><br><span class="line"><span class="keyword">type</span> Complex <span class="keyword">interface</span> &#123;</span><br><span class="line">	~<span class="keyword">complex64</span> | ~<span class="keyword">complex128</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OrderedAbs 是一个帮助类型，它定义了支持排序数值类型的 Abs 方法</span></span><br><span class="line"><span class="keyword">type</span> OrderedAbs[T OrderedNumeric] T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a OrderedAbs[T])</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">OrderedAbs</span>[<span class="title">T</span>]</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> -a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ComplexAbs 是一个帮助类型，它为复数类型定义了 Abs 方法</span></span><br><span class="line"><span class="keyword">type</span> ComplexAbs[T Complex] T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ComplexAbs[T])</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">ComplexAbs</span>[<span class="title">T</span>]</span> &#123;</span><br><span class="line">	d := math.Hypot(<span class="keyword">float64</span>(<span class="built_in">real</span>(a)), <span class="keyword">float64</span>(<span class="built_in">imag</span>(a)))</span><br><span class="line">	<span class="keyword">return</span> ComplexAbs[T](<span class="built_in">complex</span>(d, <span class="number">0</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们可以定义为调用者完成工作的函数，方法是与我们刚刚定义的类型相互转换。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OrderedAbsDifference 返回 a 和 b 差的绝对值，这里 a 和 b 是有序类型。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OrderedAbsDifference</span>[<span class="title">T</span> <span class="title">OrderedNumeric</span>]<span class="params">(a, b T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> T(AbsDifference(OrderedAbs[T](a), OrderedAbs[T](b)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ComplexAbsDifference 返回 a 和 b 差的绝对值，这里a 和 b 是复数类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ComplexAbsDifference</span>[<span class="title">T</span> <span class="title">Complex</span>]<span class="params">(a, b T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> T(AbsDifference(ComplexAbs[T](a), ComplexAbs[T](b)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，这种设计还不够强大，无法编写如下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数是无效的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GeneralAbsDifference</span>[<span class="title">T</span> <span class="title">Numeric</span>]<span class="params">(a, b T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> (<span class="keyword">interface</span>&#123;&#125;)(a).(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">int</span>, <span class="keyword">int8</span>, <span class="keyword">int16</span>, <span class="keyword">int32</span>, <span class="keyword">int64</span>,</span><br><span class="line">		<span class="keyword">uint</span>, <span class="keyword">uint8</span>, <span class="keyword">uint16</span>, <span class="keyword">uint32</span>, <span class="keyword">uint64</span>, <span class="keyword">uintptr</span>,</span><br><span class="line">		<span class="keyword">float32</span>, <span class="keyword">float64</span>:</span><br><span class="line">		<span class="keyword">return</span> OrderedAbsDifference(a, b) <span class="comment">// 无效</span></span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">complex64</span>, <span class="keyword">complex128</span>:</span><br><span class="line">		<span class="keyword">return</span> ComplexAbsDifference(a, b) <span class="comment">// 无效</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对 OrderedAbsDifference 和 ComplexAbsDifference 的调用无效，因为并非所有实现 Numeric 约束的类型都可以实现 OrderedNumeric 或 Complex 约束。 尽管类型切换意味着此代码在概念上将在运行时工作，但不支持在编译时编写此代码。 这是表达上面列出的遗漏之一的另一种方式：这种设计不提供特殊化。</p>
<h3 id="Acknowledgements"><a href="#Acknowledgements" class="headerlink" title="Acknowledgements"></a>Acknowledgements</h3><p>我们要感谢Go团队中的许多人、Go问题跟踪器的许多贡献者，以及所有分享他们的想法和对早期设计草案的反馈的人。我们阅读了所有内容，我们很感激。</p>
<p>特别是对于这个版本的提案，我们收到了来自 Josh Bleecher-Snyder、Jon Bodner、Dave Cheney、Jaana Dogan、Kevin Gillette、Mitchell Hashimoto、Chris Hines、Bill Kennedy、Ayke van Laethem、Daniel Martí、Elena Morozova、Roger 的详细反馈 佩佩和罗娜·斯坦伯格。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>本附录涵盖了设计的各种细节，这些细节似乎不足以在前面的部分中涵盖。</p>
<h2 id="泛型类型别名"><a href="#泛型类型别名" class="headerlink" title="泛型类型别名"></a>泛型类型别名</h2><p>类型别名可以引用泛型类型，但类型别名可能没有自己的参数。 存在此限制是因为不清楚如何处理具有约束的类型参数的类型别名。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> VectorAlias = Vector</span><br></pre></td></tr></table></figure>
<p>在这种情况下，类型别名的使用必须提供适合被别名的泛型类型的类型参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v VectorAlias[<span class="keyword">int</span>]</span><br></pre></td></tr></table></figure>
<p>类型别名可能也指向实例化的类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> VectorInt = Vector[<span class="keyword">int</span>]</span><br></pre></td></tr></table></figure>
<h2 id="实例化函数"><a href="#实例化函数" class="headerlink" title="实例化函数"></a>实例化函数</h2><p>Go 通常允许您在不传递任何参数的情况下引用函数，从而生成函数类型的值。 您不能对具有类型参数的函数执行此操作； 所有类型参数必须在编译时已知。 也就是说，您可以通过传递类型参数来实例化函数，但您不必调用实例化。 这将产生一个没有类型参数的函数值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PrintInts 是 func([]int) 类型</span></span><br><span class="line"><span class="keyword">var</span> PrintInts = Print[<span class="keyword">int</span>]</span><br></pre></td></tr></table></figure>
<h2 id="内嵌类型参数"><a href="#内嵌类型参数" class="headerlink" title="内嵌类型参数"></a>内嵌类型参数</h2><p>当一个泛型类型是结构体，并且类型参数是内嵌作为结构体一个字段，字段名字是类型参数的名字。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lockable 是一个可以安全地同时从多个goroutines 通过 Get 和 Set 方法访问的值。</span></span><br><span class="line"><span class="keyword">type</span> Lockable[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">	T</span><br><span class="line">	mu sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get 返回存储在 Lockable 中的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Lockable[T])</span> <span class="title">Get</span><span class="params">()</span> <span class="title">T</span></span> &#123;</span><br><span class="line">	l.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> l.mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> l.T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set 设置Lockable 的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Lockable[T])</span> <span class="title">Set</span><span class="params">(v T)</span></span> &#123;</span><br><span class="line">	l.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> l.mu.Unlock()</span><br><span class="line">	l.T = v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内嵌类型参数方法"><a href="#内嵌类型参数方法" class="headerlink" title="内嵌类型参数方法"></a>内嵌类型参数方法</h2><p>当泛型类型是结构体时，并且类型参数是内嵌的结构体字段，类型参数的约束的任何方法被提升到结构体的方法。（出于选择器解析的目的，这些方法被视为位于类型参数的深度0，即使在实际类型参数中这些方法本身是从内嵌类型中提升的）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NamedInt 一个有名字的 int. 名字可以是有 String 方法的任何类型。</span></span><br><span class="line"><span class="keyword">type</span> NamedInt[Name fmt.Stringer] <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name</span><br><span class="line">	val <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Name 返回 NamedInt 的名字</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ni NamedInt[Name])</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="comment">// String 方法是从内嵌的 Name 中提升的</span></span><br><span class="line">	<span class="keyword">return</span> ni.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内嵌的实例化类型"><a href="#内嵌的实例化类型" class="headerlink" title="内嵌的实例化类型"></a>内嵌的实例化类型</h2><p>当内嵌一个实例化的类型，字段的名字是没有类型参数的名字。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">	T[<span class="keyword">int</span>] <span class="comment">// 字段名字是T</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">(v S)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> v.T <span class="comment">// 而不是 v.T[int]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型类型作为类型switch-case-时"><a href="#泛型类型作为类型switch-case-时" class="headerlink" title="泛型类型作为类型switch case 时"></a>泛型类型作为类型switch case 时</h2><p>泛型类型可以被用作类型断言或类型 switch 中case 的类型。</p>
<p>这是一些琐碎的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Assertion</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(T, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	t, ok := v.(T)</span><br><span class="line">	<span class="keyword">return</span> t, ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Switch</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(T, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> v := v.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> T:</span><br><span class="line">		<span class="keyword">return</span> v, <span class="literal">true</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">var</span> zero T</span><br><span class="line">		<span class="keyword">return</span> zero, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在类型 switch 中，如果泛型类型结果证明跟 type switch 中其它case 是重复也没有问题，第一个匹配的 case 会被选中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Switch2</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> v.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> T:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// S2a 将被设置成0</span></span><br><span class="line"><span class="keyword">var</span> S2a = Switch2[<span class="keyword">string</span>](<span class="string">"a string"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// S2b 将被设置成</span></span><br><span class="line"><span class="keyword">var</span> S2b = Switch2[<span class="keyword">int</span>](<span class="string">"another string"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="约束元素的类型集"><a href="#约束元素的类型集" class="headerlink" title="约束元素的类型集"></a>约束元素的类型集</h2><p>就像接口类型的类型集是接口元素的类型集的交集一样，接口类型的方法集可以定义为接口元素的方法集的并集。在大多数情况下，内嵌元素没有方法，这样不会贡献任何方法给接口类型。这就是说，为了完整性起见，我们将注意到，~T的方法集是T的方法集。联合元素的方法集是联合元素的方法集的交集。这些规则隐含在类型集的定义中，但它们不是理解约束行为所必需的。</p>
<h2 id="允许约束作为普通接口类型"><a href="#允许约束作为普通接口类型" class="headerlink" title="允许约束作为普通接口类型"></a>允许约束作为普通接口类型</h2><p>这是我们现在不建议的特性，但是该语言的以后的更高版本可以考虑。</p>
<p>我们建议约束可以嵌入一些额外的元素。有了这个提议，任何嵌入接口类型以外的的任何内容的接口类型只能用作约束，或作为另一个约束中的嵌入元素。下一步自然是允许使用嵌入任何类型或嵌入这些新元素的接口类型作为普通类型，而不仅仅是作为约束。</p>
<p>我们现在不建议我这样做。但是上面的类型集和方法集的规则描述了它们的行为方式。作为类型集元素的任何类型都可以分配给这样的接口类型。这种接口类型的值将允许调用方法集的任何成员。</p>
<p>这将允许其他语言称为sum类型或union类型的版本。这将是一个GO接口类型，只能分配特定类型。当然，这样的接口类型仍然可以取值nil，因此它与其他语言中的典型sum类型不太一样。</p>
<p>另一个自然的下一步是在类型 switch case 中允许近似元素和联合元素。这将更容易确定使用这些元素的接口类型的内容。也就是说，近似元素和联合元素不是类型，因为不能在类型断言中使用。</p>
<h2 id="组合字面量的类型推断"><a href="#组合字面量的类型推断" class="headerlink" title="组合字面量的类型推断"></a>组合字面量的类型推断</h2><p>这是一个现在我不建议的特性，但是语言将来的版本可以考虑。</p>
<p>我们可以考虑泛型的组合字面量支持类型推断。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pair[T any] <span class="keyword">struct</span> &#123; f1, f2 T &#125;</span><br><span class="line"><span class="keyword">var</span> V = Pair&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// 推断为 Pair[int]&#123;1, 2&#125;</span></span><br></pre></td></tr></table></figure>
<p>目前尚不清楚这在实际代码中出现的频率。</p>
<h2 id="泛型函数参数的类型推断"><a href="#泛型函数参数的类型推断" class="headerlink" title="泛型函数参数的类型推断"></a>泛型函数参数的类型推断</h2><p>这是一个我们现在不建议的特性，但是语言将来的版本可以考虑。</p>
<p>在下面的例子中，思考在 FindClose 中对 Find 的调用。类型推断可以确定 Find 的类型参数是 T4，并且从这里我们可以知道最终的参数必须是<code>func(T4, T4) bool</code>，并且从这里我们可以推论出IsClose 的类型参数必须是 T4。然而，之前描述的类型推断算法做不到这些，所以我们必须明确的写<code>IsClose[T4]</code>。</p>
<p>起初这可能看很深奥，但在将泛型函数传递给泛型Map和 Filter 函数时就会出现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Differ 有一个 Diff 方法，它返回值的差</span></span><br><span class="line"><span class="keyword">type</span> Differ[T1 any] <span class="keyword">interface</span> &#123;</span><br><span class="line">	Diff(T1) <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IsClose 返回 a 和 b 是否更接近，基于 Diff 实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsClose</span>[<span class="title">T2</span> <span class="title">Differ</span>]<span class="params">(a, b T2)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a.Diff(b) &lt; <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find 返回 s 中与 e 匹配的第一个元素的索引，基于 cmp 函数。如果没有元素匹配，则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Find</span>[<span class="title">T3</span> <span class="title">any</span>]<span class="params">(s []T3, e T3, cmp <span class="keyword">func</span>(a, b T3)</span> <span class="title">bool</span>) <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		<span class="keyword">if</span> cmp(v, e) &#123;</span><br><span class="line">			<span class="keyword">return</span> i</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FindClose 返回s中第一个元素的索引，即接近e，基于 IsClose</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindClose</span>[<span class="title">T4</span> <span class="title">Differ</span>]<span class="params">(s []T4, e T4)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 使用当前的类型推断算法我们必须明确的写 IsClose[T4]，虽然它是我们可能使用的唯一参数。</span></span><br><span class="line">	<span class="keyword">return</span> Find(s, e, IsClose[T4])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型参数的反射"><a href="#类型参数的反射" class="headerlink" title="类型参数的反射"></a>类型参数的反射</h2><p>尽管我们不建议更改 reflect 包，但未来考虑的一种可能性为 reflect.Type 添加两个新方法：<code>NumTypeArgument() int</code>将会返回类型参数的数量，<code>TypeArgument(i) Type</code>将返回第i个类型参数。对于实例化的泛型类型，NumTypeArguemt 将返回非零值。可以为reflect.Value 定义类似的方法，对于实例化的泛型函数，NumTypeArgument 将返回非零值。可能有一些程序关心这些信息。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://fantasyczl.com/2022/04/05/20220405-go-generic-proposal/" data-id="cl2romu6z0000324id9w82m8b" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go/" rel="tag">Go</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-20210522-http-code-502-vs-504" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/22/20210522-http-code-502-vs-504/" class="article-date">
  <time datetime="2021-05-22T04:05:54.000Z" itemprop="datePublished">2021-05-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/22/20210522-http-code-502-vs-504/">HTTP 状态码 502 与 504 的区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>线上偶尔会有502或者504的报错. 我们访问网页的时候也经常会有. 那么它们到底有什么区别呢?<br>今天就查了一些资料, 来学习一下.</p>
<h2 id="先来看释义"><a href="#先来看释义" class="headerlink" title="先来看释义:"></a>先来看释义:</h2><ul>
<li>502: Bad Gateway. 表示web server 做为了一个gateway 或者 proxy 的时候, 从上游接受到了无效的 response.</li>
<li>504: Gateway Timeout. 表示web server 做为一个gateway 或者 proxy 的时候, 无法即时的从上游得到一个response, 来完成请求.</li>
</ul>
<p>看起来好像差不多. 但在实际开发中, 凭经验, 好像502, 504都是因为超时.</p>
<h2 id="LNMP-下来看一下502-504"><a href="#LNMP-下来看一下502-504" class="headerlink" title="LNMP 下来看一下502, 504"></a>LNMP 下来看一下502, 504</h2><p>下面结合 LNMP 的情形下来来看一下.</p>
<h2 id="Nginx-产生-502-的原因"><a href="#Nginx-产生-502-的原因" class="headerlink" title="Nginx 产生 502 的原因"></a>Nginx 产生 502 的原因</h2><ul>
<li>PHP-FPM 没有运行</li>
<li>Nginx 无法连接 PHP-FPM</li>
</ul>
<h3 id="PHP-FPM-没有启动"><a href="#PHP-FPM-没有启动" class="headerlink" title="PHP-FPM 没有启动"></a>PHP-FPM 没有启动</h3><p>如果因为这些原因, Nginx 无法连上 PHP-FPM, 那么将会导致 502. access.log 中:<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0.0.1</span> - - <span class="string">[22/May/2021:17:36:19 +0800]</span> <span class="string">"<span class="keyword">GET</span> / HTTP/1.1"</span> <span class="number">502</span> <span class="number">158</span> <span class="string">"-"</span> <span class="string">"curl/7.76.1"</span> <span class="string">"-"</span></span><br></pre></td></tr></table></figure><br>这时候 error.log 中为:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect() <span class="keyword">to</span> unix:/<span class="built_in">run</span>/php/php7<span class="number">.2</span>-fpm.sock failed (<span class="number">2</span>: No such <span class="built_in">file</span> <span class="keyword">or</span> directory) <span class="keyword">while</span> connecting <span class="keyword">to</span> upstream</span><br></pre></td></tr></table></figure><br>这可能是因为没有启动 PHP-FPM, 启动就好了.</p>
<h3 id="PHP-FPM-处理超时"><a href="#PHP-FPM-处理超时" class="headerlink" title="PHP-FPM 处理超时"></a>PHP-FPM 处理超时</h3><p>如果你的应用反应时间太长, 将会产生一个超时的错误. 如果 PHP-FPM 的超时设置比 Nginx 的超时设置小. Nginx 将会返回 502.<br>这是因为 PHP-FPM 关闭了连接.</p>
<p>error.log 将会显示:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recv() failed (104:<span class="built_in"> Connection </span>reset by peer) <span class="keyword">while</span> reading response header <span class="keyword">from</span> upstream</span><br></pre></td></tr></table></figure></p>
<p>这个时候, 如果有 php-fpm 日志, 将会显示:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARNING: [pool mypool] child 2120,<span class="built_in"> script </span><span class="string">'/var/www/html/index.php'</span> (request: <span class="string">"GET /index.php"</span>) execution timed out (25.755070 sec), terminating</span><br></pre></td></tr></table></figure></p>
<h3 id="PHP-FPM-没有超时-Nginx-超时"><a href="#PHP-FPM-没有超时-Nginx-超时" class="headerlink" title="PHP-FPM 没有超时, Nginx 超时"></a>PHP-FPM 没有超时, Nginx 超时</h3><p>如果这个时候你调高了 php-fpm 的超时时间, 这将引发另一个问题, nginx 可能会没有接收到 PHP-FPM 的响应而超时, 这个时候 Nginx 会返回 504.</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>(502)[<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/502]" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/502]</a></li>
<li>(504)[<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/504]" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/504]</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://fantasyczl.com/2021/05/22/20210522-http-code-502-vs-504/" data-id="cl1s1y8my0004yv4ihq4l1s23" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nginx/" rel="tag">Nginx</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-20210328-golang-cpu-too-high" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/28/20210328-golang-cpu-too-high/" class="article-date">
  <time datetime="2021-03-28T06:42:46.000Z" itemprop="datePublished">2021-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/28/20210328-golang-cpu-too-high/">一个Go服务占用CPU太高的优化过程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近上线一个Go服务, 在高峰期总是会报CPU超70%的报警.<br>然后就打开 pprof 开始追踪, 发现近 50% 的CPU被 runtime.gcDrain 及相关的 gc 函数占用了.</p>
<p>这说明 gc 很活跃.</p>
<p>这时候也不知道从哪里入手. 大概只有两个方向, 看一下 heap 的情况:</p>
<ol>
<li>看看哪里占的内存总多</li>
<li>看看哪里分配的对象最多</li>
</ol>
<p>最后定位到解码的函数, json 和 mapstructure.<br>仔细看了之后, 发现这里有很多直接传值的地方, 而不是传指针. 修改后, 再压测: 有改善, 但不明显.</p>
<p>这个时候就没有什么思路了.</p>
<p>经同事提醒. 再优化 elasticsearch 取数据的地方, 只取需要的 fields. 再压测, 发现有小幅提升. 但仍不明显.<br>跟同事讨论的时候, 我发现问题并不是CPU占用太高了, 而是CPU占用很高, 内存占用很少, 很不均衡. CPU占用70%, 内存不超过5%.</p>
<p>那搜索一下, 发现 Go 提供了一个 GOGC 的变量, 可以设置触发 GC 的值. 运行时也可以通过 <code>runtime/debug 包的 func SetGCPercent(percent int) int</code> 来修改.<br>默认是100, 那先修改成 500 看一下. 发现效果明显. CPU 降低了 50%.</p>
<p>问题解决了!!! 优化了一个星期, 改了很多代码. 最后是一行代码解决了!!!</p>
<p>不过目前看来 500 也有点低, 下次再调一下找一个更合理的值.</p>
<p>所以这个问题的原因是: 我们这个服务不是个CPU密集型的应用, 但是CPU占用过高, 而内存占用很低. (嗯, 只能说 Go 的 GC 很给力).<br>那这种情况下, 应该先看看, 是否可以降低触发 Gc 的阈值看一下, 也许就是你要的.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://fantasyczl.com/2021/03/28/20210328-golang-cpu-too-high/" data-id="cl1s1y8mx0002yv4ifljafvgf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go/" rel="tag">Go</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-20210218-golang-optimization" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/02/18/20210218-golang-optimization/" class="article-date">
  <time datetime="2021-02-18T08:02:36.000Z" itemprop="datePublished">2021-02-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/02/18/20210218-golang-optimization/">Go 优化Tips</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天看了一篇博客，介绍Go性能压测与pprof. 地址: <a href="https://artem.krylysov.com/blog/2017/03/13/profiling-and-optimizing-go-web-applications/" target="_blank" rel="noopener">profiling-and-optimizing-go-web-applications</a></p>
<p>其中总结的优化Tips很不错：</p>
<ol>
<li>避免不必要的 heap 申请</li>
<li>对于不大的结构体，使用值比指针更好</li>
<li>对于maps和slice, 如果提前知道大小，最好预分配大小</li>
<li>如果不是必要，就不打LOG</li>
<li>如果做很多顺序读写，使用 buffered I/O</li>
<li>如果你的应用重度使用JSON，考虑使用生成器的分析序列化工具。If your application extensively uses JSON, consider utilizing parser/serializer generators (I personally prefer easyjson).</li>
<li>热点path 的每个操作都到头重要。 Every operation matters in a hot path.</li>
</ol>
<p>原文：</p>
<ol>
<li>Avoid unnecessary heap allocations.</li>
<li>Prefer values over pointers for not big structures.</li>
<li>Preallocate maps and slices if you know the size beforehand.</li>
<li>Don’t log if you don’t have to.</li>
<li>Use buffered I/O if you do many sequential reads or writes.</li>
<li>If your application extensively uses JSON, consider utilizing parser/serializer generators (I personally prefer easyjson).</li>
<li>Every operation matters in a hot path.</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://fantasyczl.com/2021/02/18/20210218-golang-optimization/" data-id="cl1s1y8mz0005yv4ig3ty6bl9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go/" rel="tag">Go</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-20200827-php-subpattern" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/27/20200827-php-subpattern/" class="article-date">
  <time datetime="2020-08-27T09:42:37.000Z" itemprop="datePublished">2020-08-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/27/20200827-php-subpattern/">PHP 中多个 Subpattern 匹配问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天无意中看到多个小括号嵌套的正则表达式. 突然就想, 那么匹配出来后的排序是怎么样的? 于是决定看一下文档.<br>文档地址: <a href="https://www.php.net/manual/en/regexp.reference.subpatterns.php" target="_blank" rel="noopener">https://www.php.net/manual/en/regexp.reference.subpatterns.php</a></p>
<h2 id="什么是子模式-Subpattern"><a href="#什么是子模式-Subpattern" class="headerlink" title="什么是子模式 (Subpattern)"></a>什么是子模式 (Subpattern)</h2><p>子模式通过小括号来界定. 它有两个作用:</p>
<ol>
<li>局部化一组可替代方案. 例如: (sun|mon)day, 既匹配 sunday, 也匹配 monday. 如果不用小括号的写法是 sunday|monday.</li>
<li>它建立一组可捕捉的子模式. 当整个模式匹配时, 匹配子模式的字符串通过参数传回给调用者(像 preg_match 中的 match参数). match 是个数组. 它从左到右按开括号的顺序数, (从1开始) 去获取捕捉字符串的数量.</li>
</ol>
<p>例如:<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">字符串 <span class="string">"the red king"</span> 匹配模式 ((<span class="built_in">red</span>|<span class="type">white</span>)(king|<span class="type">queen</span>)). </span><br><span class="line">捕捉子字符串就是 <span class="string">"red king"</span>, <span class="string">"red"</span>, <span class="string">"king"</span>. 下标分别是 <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>再来看一个例子:<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">模式是 /((Sat)ur|(Sun))day/</span><br><span class="line">匹配字符串 Saturday 的结果是, 捕捉子字符串分别是 <span class="number">1</span> =&gt; Satur, <span class="number">2</span> =&gt; Sat</span><br><span class="line">匹配字符串 Sunday 的结果是, 捕捉子字符串分别是 <span class="number">1</span> =&gt; Sun, <span class="number">2</span> =&gt; <span class="string">''</span>, <span class="number">3</span> =&gt; Sun</span><br></pre></td></tr></table></figure></p>
<p>仔细想想为什么?</p>
<h2 id="数量限制"><a href="#数量限制" class="headerlink" title="数量限制"></a>数量限制</h2><p>捕捉子字符串最多 65535 个. 不过一般不会到这个上限. 应该能满足大多数的需要.</p>
<h2 id="如何关闭捕捉子模式"><a href="#如何关闭捕捉子模式" class="headerlink" title="如何关闭捕捉子模式?"></a>如何关闭捕捉子模式?</h2><p>有的时候, 我们可能只想使用它的多组替代方案的功能(上面第1点), 而不想使用它的捕捉功能(上面第2点). 那该怎么做呢?<br>如果在左小括号后, 紧跟 “?:” 字符, 那么子模式不再时行捕捉, 并且在计算子模式的捕捉子序列时也不再计数.</p>
<p>例如:<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">((?:<span class="built_in">red</span>|<span class="type">white</span>)(king|<span class="type">queen</span>)) 匹配字符串 white queen 时,</span><br><span class="line">子模式匹配的子序列分别是: white queen, queen, 下标分别为<span class="number">1</span>,<span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<h2 id="可互相替代的组号"><a href="#可互相替代的组号" class="headerlink" title="可互相替代的组号"></a>可互相替代的组号</h2><p>有时候需要有多个匹配的子模式, 但是他们的子组号可互相替代, 就是子组号要一样.<br>正常情况下, 每个子模式都会有一个后向引用的组号, 即使它们当中只有一个子模式会被匹配到.<br>解决这个问题, 需要 “?|”, 它允许产生重复的组号</p>
<p>比如:<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(?:(Sat)ur|<span class="type">(Sun</span>))day 匹配 Sunday, 子模式的匹配序列为: <span class="number">1</span> =&gt; '', <span class="number">2</span> =&gt; Sun</span><br></pre></td></tr></table></figure><br>这里 Sun 的序号是2, 即使1是空的.<br>使用 ?| 后:<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(?|<span class="type">(Sat</span>)ur|<span class="type">(Sun</span>))day 匹配 Sunday, 子模式的匹配序列为: <span class="number">1</span> =&gt; Sun</span><br><span class="line">(?|<span class="type">(Sat</span>)ur|<span class="type">(Sun</span>))day 匹配 Saturday, 子模式的匹配序列为: <span class="number">1</span> =&gt; Sat</span><br></pre></td></tr></table></figure></p>
<p>使用 ?| , Sat 和 Sun 的后向引用都是 1.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://fantasyczl.com/2020/08/27/20200827-php-subpattern/" data-id="cl1s1y8nb000myv4icmeahr2c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PHP/" rel="tag">PHP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-20200724-tcp-keepalive" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/24/20200724-tcp-keepalive/" class="article-date">
  <time datetime="2020-07-24T05:57:43.000Z" itemprop="datePublished">2020-07-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/24/20200724-tcp-keepalive/">Linux下如何设置 TCP KeepAlive</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-什么是-TCP-KeepAlive"><a href="#1-什么是-TCP-KeepAlive" class="headerlink" title="1. 什么是 TCP KeepAlive"></a>1. 什么是 TCP KeepAlive</h3><p>TCP KeepAlive 是一种机制, 检测 TCP 连接的另一端是否已经停止响应了</p>
<h3 id="2-怎么检测"><a href="#2-怎么检测" class="headerlink" title="2. 怎么检测"></a>2. 怎么检测</h3><p>TCP 在空闲一段时间之后, 将来发送包含null数据的检测包到另一端. 如果另一端没有响应, socket 就会自动关闭.</p>
<h3 id="3-如何设置"><a href="#3-如何设置" class="headerlink" title="3. 如何设置"></a>3. 如何设置</h3><p>TCP 的 KeepAlive 可以提高带宽的使用率. 那么在 Linux 下怎么设置呢?<br>Linux 系统可以通过 /ect/sysctl.conf 来进行设置.</p>
<p>如果想查看当前系统使用的设置是什么, 可以通过以下命令:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ls -l /proc/sys/net/ipv4/tcp_keepalive*</span><br><span class="line">-rw-r--r-- 1 root root 0 Jul 24 13:56 /proc/sys/net/ipv4/tcp_keepalive_intvl</span><br><span class="line">-rw-r--r-- 1 root root 0 Jul 24 13:56 /proc/sys/net/ipv4/tcp_keepalive_probes</span><br><span class="line">-rw-r--r-- 1 root root 0 Jul 24 13:56 /proc/sys/net/ipv4/tcp_keepalive_time</span><br><span class="line"></span><br><span class="line">cat /proc/sys/net/ipv4/tcp_keepalive*</span><br><span class="line">75</span><br><span class="line">9</span><br><span class="line">7200</span><br></pre></td></tr></table></figure></p>
<p>他们都代表什么意思呢?<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tcp_keepalive_time</span> = <span class="number">7200</span> (seconds)</span><br><span class="line"><span class="attr">tcp_keepalive_intvl</span> = <span class="number">75</span> (seconds)</span><br><span class="line"><span class="attr">tcp_keepalive_probes</span> = <span class="number">9</span> (number of probes)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><ol>
<li>tcp keepalive 将会 socket 的活动后, 等待 7200 秒, 才会发送第一个 keepalive 探测.</li>
</ol>
</li>
<li><ol start="2">
<li>然后它每隔 75 秒发一次探测. 只要 TCP/IP socket 正常交流并且活跃, 就不需要 keepalive 包.</li>
</ol>
</li>
<li><ol start="3">
<li>只到9次检测都失败, 将会设为失败</li>
</ol>
</li>
</ul>
<h3 id="4-如何设置"><a href="#4-如何设置" class="headerlink" title="4. 如何设置"></a>4. 如何设置</h3><ul>
<li><ol>
<li>编辑 /ect/sysclt.conf 文件<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vi</span> /etc/sysctl.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="2">
<li>编辑或添加配置<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">net.ipv4.tcp_keepalive_time</span> = <span class="number">60</span></span><br><span class="line"><span class="attr">net.ipv4.tcp_keepalive_intvl</span> = <span class="number">10</span></span><br><span class="line"><span class="attr">net.ipv4.tcp_keepalive_probes</span> = <span class="number">6</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="3">
<li>加载配置使之生效<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sysctl -p</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://fantasyczl.com/2020/07/24/20200724-tcp-keepalive/" data-id="cl1s1y8mr0000yv4i6pj83k2q" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NetWork/" rel="tag">NetWork</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP/" rel="tag">TCP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-20200606-git-rebase-merge-difference" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/06/20200606-git-rebase-merge-difference/" class="article-date">
  <time datetime="2020-06-05T16:41:04.000Z" itemprop="datePublished">2020-06-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/06/20200606-git-rebase-merge-difference/">Git rebase 与 merge 的区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天看到一篇文章, 讲到了 git rebase 与 git merge 的区别. 我觉得讲的非常好.</p>
<h3 id="功能区别"><a href="#功能区别" class="headerlink" title="功能区别"></a>功能区别</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>比如一个git项目有两个分支, master 和 feature. 当前在feature 开发. 那 feature 是从 master fork 出来的.<br>这个时候, 别人也在向 master 合并代码. 那么现在 master 和 feature 已经分叉了. 这时, 如果想让master的新提交在feature也出现.<br>有两个方法, 一是git rebase, 二是git merge.</p>
<ol>
<li>git merge. 会把 master 的内容和feature的内容合并, 并产生一个新的 commit.</li>
<li>git rebase. 会把当前feautre 分支到master的根commit到最新的commit都修改一遍. 使feature与master的分叉commit 建立在 master 的最新commit 之后. 这样产生的历史是线性的.</li>
</ol>
<h4 id="git-rebase-的注意事项"><a href="#git-rebase-的注意事项" class="headerlink" title="git rebase 的注意事项"></a>git rebase 的注意事项</h4><p>git rebase 应该永远使用在私有分支上. 因为它会修改 commit, 如果是公开的分支, 会影响别人.</p>
<p>上面没有图, 只有文字说明, 比较抽象. 具体详细的说明参见: <a href="https://www.atlassian.com/git/tutorials/merging-vs-rebasing" target="_blank" rel="noopener">https://www.atlassian.com/git/tutorials/merging-vs-rebasing</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://fantasyczl.com/2020/06/06/20200606-git-rebase-merge-difference/" data-id="cl1s1y8mw0001yv4i0a1pdotf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git/" rel="tag">Git</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-how-to-make-swap-mem-in-ubuntu" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/05/how-to-make-swap-mem-in-ubuntu/" class="article-date">
  <time datetime="2020-06-05T11:08:38.000Z" itemprop="datePublished">2020-06-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/05/how-to-make-swap-mem-in-ubuntu/">怎样在Ubuntu下设置交换内存</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在云主机上更新PHP的composer的时候, 一直报错, 内存不够. htop看了一下, 一共才900多M的内存, 跑了很多软件, 已经占用了700M了.<br>没办法, 不能为了软件升个级就再买CPU吧. 只好使用交换内存了.</p>
<p>记录如下:</p>
<ol>
<li><p>检查系统是否打开了交换内存. 一般没有.</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo swapon -s</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个交换文件, 用于交换, 大小自定. 我设的是物理内存的2倍. 文件地址随意.</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo fallocate -l <span class="number">2</span>G /swapfile</span><br><span class="line">chmod <span class="number">600</span> /swapfile</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在让这个文件可以用作交换内存.</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkswap <span class="string">/swapfile</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>打开交换内存</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo swapon <span class="string">/swapfile</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>现在再检查一下交换内存是否打开(参见步骤1)</p>
</li>
<li><p>如果想要永久生效, 就是重启也有效, 需要设置 /etc/fstab 文件</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> '<span class="string">/swapfile</span> none swap sw 0 0' &gt;&gt; <span class="string">/etc/fstab</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置swappiness参数, 它表示在什么情况下使用交换内存. 取值在0-100之间, 表示在启用交换内存前, 物理内存空间的占比.<br>那么:</p>
</li>
</ol>
<ul>
<li>0: 表示关闭交换内存</li>
<li>1: 最小数量的交换内存, 但并不完全关闭</li>
<li>10: 比较推荐的值, 这样保证系统有足够的内存, 并且能保证性能.</li>
<li>100: 积极的使用交换内存. (没有使用过这个值)</li>
</ul>
<p>设置方法:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">add</span> content</span><br><span class="line">vm.<span class="attribute">swappiness</span>=10</span><br></pre></td></tr></table></figure><br>exit vim, 现在使它生效.</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo sysctl -p</span></span><br></pre></td></tr></table></figure>
<p>到这一步, 已经完成了交换的设置.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://fantasyczl.com/2020/06/05/how-to-make-swap-mem-in-ubuntu/" data-id="cl1s1y8n4000cyv4i6a7y322b" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-what-is-the-difference-between-process-and-thread" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/05/what-is-the-difference-between-process-and-thread/" class="article-date">
  <time datetime="2020-06-05T11:08:12.000Z" itemprop="datePublished">2020-06-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/05/what-is-the-difference-between-process-and-thread/">Linux下的进程和线程有什么区别?</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>进程和线程有什么不同? 或者说有什么区别?<br>我们都知道: 进程是操作系统管理资源的最小单位, 线程是系统调度的基本单位.</p>
<p>那么具体到Linux系统, 进程和线程有什么区别呢?</p>
<p>首先, 在Linux Kernel看来, 其实是没有线程的. 所有的用户线程在在内核看来都是进程, 不过是轻量级的进程(Light Weight Process). 跟普通的进程有点区别. 区别在于:<br>轻量级进程之间共享同样的地址空间以及打开的文件等资源. 相比普通进程更轻量一些.</p>
<blockquote>
<p>So, effectively we can say that threads and light weight processes are same.<br>It’s just that thread is a term that is used at user level while light weight process is a term used at kernel level.</p>
</blockquote>
<p>实际上, 我们可以说线程和轻量级进程是一样的. 只是线程是一个用户级的术语, 而轻量级进程是一个内核级的术语.</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>从实现的角度来看, 线程使用 pthread 库来创建. 它内部, 使用了 clone() 的系统调用来创建轻量级进程, 像创建普通进程一样. 这意味着创建一个普通进程的 fork() 函数, 后面也会调用 clone(), 根据创建线程或轻量级进程, 使用不同的参数.</p>
<p>所以进程和线程的主要不同, 就是调用 clone() 的传参不同.</p>
<p>系统调用 clone() 克隆一个任务, 带有一个可配置的共享级别, 它们是:</p>
<ol>
<li>CLONE_FILES: 共享同样的文件描述符表(而不是创建一个新的)</li>
<li>CLONE_PARENT: 不在新任务和旧任务之间创建父子关系. 否则的话, 子进程的 getppid() = 父进程的 getpid()</li>
<li>CLONE_VM: 共享同样的内存空间, 而不是复制一份.</li>
</ol>
<p>fork() 调用 clone(), 最少的共享.<br>pthread_create() 调用 clone(), 最多的共享.</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li><a href="https://www.thegeekstuff.com/2013/11/linux-process-and-threads/" target="_blank" rel="noopener">https://www.thegeekstuff.com/2013/11/linux-process-and-threads/</a></li>
<li><a href="https://stackoverflow.com/a/809049/2550332" target="_blank" rel="noopener">https://stackoverflow.com/a/809049/2550332</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://fantasyczl.com/2020/06/05/what-is-the-difference-between-process-and-thread/" data-id="cl1s1y8na000jyv4ihpvubuop" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Process/" rel="tag">Process</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Thread/" rel="tag">Thread</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-how-to-cat-mutiplelines-to-file" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/17/how-to-cat-mutiplelines-to-file/" class="article-date">
  <time datetime="2019-12-17T11:13:11.000Z" itemprop="datePublished">2019-12-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/17/how-to-cat-mutiplelines-to-file/">命令行中向一个文件插入多行</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>命令行中向一个文件插入多行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> possibility 1:</span></span><br><span class="line">echo "line 1" &gt;&gt; greetings.txt</span><br><span class="line">echo "line 2" &gt;&gt; greetings.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> possibility 2:</span></span><br><span class="line">echo "line 1</span><br><span class="line">line 2" &gt;&gt; greetings.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> possibility 3:</span></span><br><span class="line">cat &lt;&lt;EOT &gt;&gt; greetings.txt</span><br><span class="line">line 1</span><br><span class="line">line 2</span><br><span class="line">EOT</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://fantasyczl.com/2019/12/17/how-to-cat-mutiplelines-to-file/" data-id="cl1s1y8na000kyv4ihgqe33qv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Shell/" rel="tag">Shell</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Go/" rel="tag">Go</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Laravel/" rel="tag">Laravel</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NetWork/" rel="tag">NetWork</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nginx/" rel="tag">Nginx</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PHP/" rel="tag">PHP</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Process/" rel="tag">Process</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/" rel="tag">Shell</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/" rel="tag">TCP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Thread/" rel="tag">Thread</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/" rel="tag">vim</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/Git/" style="font-size: 13.33px;">Git</a> <a href="/tags/Go/" style="font-size: 16.67px;">Go</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Laravel/" style="font-size: 10px;">Laravel</a> <a href="/tags/Linux/" style="font-size: 20px;">Linux</a> <a href="/tags/NetWork/" style="font-size: 10px;">NetWork</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/PHP/" style="font-size: 16.67px;">PHP</a> <a href="/tags/Process/" style="font-size: 10px;">Process</a> <a href="/tags/Python/" style="font-size: 13.33px;">Python</a> <a href="/tags/Shell/" style="font-size: 13.33px;">Shell</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/Thread/" style="font-size: 10px;">Thread</a> <a href="/tags/vim/" style="font-size: 13.33px;">vim</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">八月 2015</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/04/05/20220405-go-generic-proposal/">Golang 泛型提案学习</a>
          </li>
        
          <li>
            <a href="/2021/05/22/20210522-http-code-502-vs-504/">HTTP 状态码 502 与 504 的区别</a>
          </li>
        
          <li>
            <a href="/2021/03/28/20210328-golang-cpu-too-high/">一个Go服务占用CPU太高的优化过程</a>
          </li>
        
          <li>
            <a href="/2021/02/18/20210218-golang-optimization/">Go 优化Tips</a>
          </li>
        
          <li>
            <a href="/2020/08/27/20200827-php-subpattern/">PHP 中多个 Subpattern 匹配问题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 fantasyczl<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


  </div>
</body>
</html>