<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Golang 泛型提案学习 | fantasyczl</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Go 1.18 支持泛型了。现在抽空就看了一下泛型提案。英文地址简单翻译如下：  翻译名词对照 type &#x3D;&gt; 类型 constrain &#x3D;&gt; 结束 interface &#x3D;&gt; interface  摘要我们建议扩展Go语言，对类型和函数声明添加可选的类型参数。类型参数被 interface 类型约束。当 interface 类型被用作类型限制的时候，可以支持添加额外的元素，用来">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang 泛型提案学习">
<meta property="og:url" content="http://fantasyczl.com/2022/04/05/20220405-go-generic-proposal/index.html">
<meta property="og:site_name" content="fantasyczl">
<meta property="og:description" content="Go 1.18 支持泛型了。现在抽空就看了一下泛型提案。英文地址简单翻译如下：  翻译名词对照 type &#x3D;&gt; 类型 constrain &#x3D;&gt; 结束 interface &#x3D;&gt; interface  摘要我们建议扩展Go语言，对类型和函数声明添加可选的类型参数。类型参数被 interface 类型约束。当 interface 类型被用作类型限制的时候，可以支持添加额外的元素，用来">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-04-05T10:06:04.000Z">
<meta property="article:modified_time" content="2022-05-02T04:00:37.177Z">
<meta property="article:author" content="fantasyczl">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="fantasyczl" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 4.2.1"></head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">fantasyczl</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">生命是一个过程，生命的精彩在于体验</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://fantasyczl.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-20220405-go-generic-proposal" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/05/20220405-go-generic-proposal/" class="article-date">
  <time datetime="2022-04-05T10:06:04.000Z" itemprop="datePublished">2022-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Golang 泛型提案学习
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Go 1.18 支持泛型了。现在抽空就看了一下泛型提案。<a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md" target="_blank" rel="noopener">英文地址</a><br>简单翻译如下：</p>
</blockquote>
<h1 id="翻译名词对照"><a href="#翻译名词对照" class="headerlink" title="翻译名词对照"></a>翻译名词对照</h1><ul>
<li>type =&gt; 类型</li>
<li>constrain =&gt; 结束</li>
<li>interface =&gt; interface</li>
</ul>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>我们建议扩展Go语言，对类型和函数声明添加可选的类型参数。类型参数被 interface 类型约束。当 interface 类型被用作类型限制的时候，可以支持添加额外的元素，用来限制满足 interface 的类型的集合。参数化的类型和函数可能会使用参数的操作，但这种情况只有在所有满足参数约束的类型都允许才行。类型 interface 通过一个统一的算法进行类型推断，以允许在函数调用的时候去掉类型参数。这个设计对 Go1 完全后向兼容。</p>
<h1 id="怎么读这个提案"><a href="#怎么读这个提案" class="headerlink" title="怎么读这个提案"></a>怎么读这个提案</h1><p>这个文章非常长，这是如何阅读的指导：</p>
<ul>
<li>我们从一个高级的概述开始，非常简单的描述概念</li>
<li>然后我们从零开始解释全部的设计，介绍详情，并有简单的例子</li>
<li>在设计全部描述完之后，我们讨论实现，一些设计的问题，然后跟其它的泛型方法比较。</li>
<li>然后我用几个完整的例子，以展示这个实现在实践中是如何使用的。</li>
<li>例子之后，在附录中谈论了一些小的细节。</li>
</ul>
<h1 id="高级别的概述"><a href="#高级别的概述" class="headerlink" title="高级别的概述"></a>高级别的概述</h1><p>这部分非常简要的描述了这个设计建议的修改。这部分是为那些已经熟悉一个语言中, 泛型如何工作的人准备的。这些概念在后面的章节中会有详细的解释。</p>
<ul>
<li>函数可以有一个使用方括号的额外的类型参数列表，但是其它方面像一个普通的参数列表。<code>func F[T any](p T) {...}</code></li>
<li>这些类型参数可以被普通参数使用，也可以在函数体内使用。</li>
<li>类型也可以有类型参数列表：<code>type M[T any] []T</code>.</li>
<li>每个类型参数都有一个类型约束，就像每个普通参数都有一个类型一样：<code>func F[T Constraint](p T) {...}</code></li>
<li>类型约束是 interface 类型。</li>
<li>新的预定义的约束 <code>any</code> 是一个允许所有类型的类型约束。</li>
<li>当 interface 类型作为类型约束的时候，可以另外嵌入元素以限制满足约束的类型集合：<ul>
<li>一个任意的类型 <code>T</code> 限制只能用那个类型。</li>
<li>近似元素 <code>~T</code> 限制只能使用那些底层类型是 T 的类型。</li>
<li>联合元素 <code>T1 | T2 | ...</code> 限制只能使用列出来的类型。</li>
</ul>
</li>
<li>泛型函数使用的操作，必须被所有符合约束的类型都支持。</li>
<li>使用泛型函数或类型，必须传一个类型参数。</li>
<li>在常见情况下，类型推断允许去掉一个函数的类型参数。</li>
</ul>
<p>在接下来的部分中，我们将会对这些语言的修改详细的过一遍，你可能更想跳过开头，到例子部分，看一下实践中的泛型代码是怎么写的。</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在 Go 中，已经有很多要求支持泛型的请求的了。在 issue traker 上也有大量的讨论。</p>
<p>这个设计建议，通过添加一种参数多态的形式，对 Go 语言进行扩展，这里的类型参数不是被声明的子类型关系限制的（就像别的面向对象语言一样），而是被明确定义的结构化约束限制。</p>
<p>这个版本的设计跟2019年7月31号的设计草稿有很多相似的地方，不过 contracts 已经去掉了，替换成了 interface 类型，并且语法也有改变。</p>
<p>针对增加类型参数，已经有几个提案了，可以通过以前的链接找到。这里呈现的很多想法之前也出现过。这里描述的主要新特性是语法和 interface 类型作为约束的仔细检查。</p>
<p>这个设计不支持模板元编程或其它任何形式的编译时编程。</p>
<p>因为术语 <code>generic</code> 在 Go 社区广泛使用，我们下面将使用它来代表一个带着类型参数的函数或类型。不要将本设计中使用的术语 generic 跟其它语言像 C++, C#, Java 或 Rust 中使用的同样的术语搞混淆。它们有相似的地方但是不一样。</p>
<h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><p>我们将分阶段基于例子来描述完整的设计。</p>
<h2 id="类型参数"><a href="#类型参数" class="headerlink" title="类型参数"></a>类型参数</h2><p>泛型代码是使用抽象的数据类型来写的，这种抽象数据类型，我们称作<strong>类型参数</strong>。当运行泛型代码的时候，类型参数将被实际参数替换。</p>
<p>这是一个函数，它输出 slice 中的每个元素，这里 slice 中元素的类型 <code>T</code> 是未知的。这是为了支持泛型编程我们想要允许的函数中，一个微不足道的例子。（稍后我们将讨论泛型类型）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Print 输出 slice 中的元素。</span></span><br><span class="line"><span class="comment">// 它可能被传入任何类型的 slice.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(s []T)</span></span> &#123;  <span class="comment">// 只是一个例子，不是建议的语法</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中，第一个需要做的决定是：类型参数 T 怎么被声明？在像 Go 这样的语言中，我们希望每一个标识符都以某种方式被声明。</p>
<p>这里我做一个设计决定：类型参数跟普通的非类型函数参数相似，并且跟其它参数一起列出来。然而，类型参数跟非类型参数不一样，所以虽然它们都出现在参数列表中，但是我们想要区分它们。这会导致我们下一个设计决定：我们定义一个另外的可选的参数列表来描述类型参数。</p>
<p>类型参数列表出现在普通参数前面。为了区分类型参数列表和普通参数列表，类型参数列表使用方括号而不是小圆括号。就像普通参数拥有类型，类型参数也有元类型，就是约束。我们稍后将讨论约束的细节。现在我们只需要知道 <code>any</code> 是一个有效的约束，意思是任意类型都可以。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Print 输出任意 slice 的元素。</span></span><br><span class="line"><span class="comment">// Print 有一个类型参数 T 和一个单个的普通参数 s, 它是一个 slice, slice的元素类型是 T</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(s []T)</span></span> &#123;</span><br><span class="line">    <span class="comment">// same as above</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是说在 Print 函数中，标识符 T 是一个类型参数，这个类型现在还不知道，但是当函数被调用时就知道了。<code>any</code>的意思是<code>T</code>可以是任何类型。就像上面看到的，当描述普通的非类型参数时，类型参数可以被当作类型使用。在函数体中，它也可以当作类型使用。</p>
<p>跟普通参数列表不一样的是，在类型参数列表中名字是必须的。这可以避免语法歧义，并且没有任何理由去省略类型参数的名字。</p>
<p>由于 Print 有一个类型参数，所有对 Print 的调用必须提供一个类型参数。稍后我们将看到这个类型参数怎么通过非类型参数推断出来。现在我们将明确的传入类型参数。类型参数被传入，就相当于类型参数被声明了：作为一个分享的参数列表。当有类型参数列表时，使用方括号。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 []int 调用 Print.</span></span><br><span class="line"><span class="comment">// Print 有一个类型参数 T，并且我们想传入 []int，</span></span><br><span class="line"><span class="comment">// 所以我们传一个 int 类型参数，这么写 Print[int].</span></span><br><span class="line"><span class="comment">// Print[int] 函数期望参数是 []int</span></span><br><span class="line">Print[<span class="keyword">int</span>]([]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这将会输出</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>让我们的例子稍微复杂点。比如有一个函数，它将为了把一个任意类型的 slice 转换成 []string, 将通过调用每个元素的 String 方法来实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法是非法的。只是演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stringify</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(s []T)</span> <span class="params">(ret []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        ret = <span class="built_in">append</span>(ret, v.String())   <span class="comment">// 非法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一眼看上去好像可以，不过这个例子中 v 的类型是 T, 而 T 可以是任何类型。这意味着 T 不需要有 String 方法。所以 v.String() 的调用是非法的。</p>
<p>当然了，同样的问题在其它支持泛型的语言中也存在。例如在 C++ 中，一个泛型函数（用C++的术语，一个函数模板）可以调用一个泛型类型的值的任意方法。就是在 C++ 中，调用 v.String() 是可以的。如果函数调用使用了一个类型参数，它没有 String 方法，编译的时候会报错。这些报错可能很长，比如在报错发生前有好几层的泛型函数调用时，为了明白哪里出错了，所有这些都需要报出来。</p>
<p>C++ 的方案对 Go 来说是个糟糕的选择。一个原因是语言的风格。在 Go 中我们不引用名字，比如，在这个例子中，String, 并且希望它们存在。当它们被看见的时候，Go 解析所有的名字到它们声明的地方。</p>
<p>另一个原因是 Go 被设计用来支持大规模编程的。我们必须考虑这个例子中泛型函数的定义（上面的 Stringify）以及对泛型函数的调用（没有显示，不过可能在其它包中）相距甚远的情况。一般来讲，所有的泛型代码期望类型参数符合某种确定的要求。我们当这种要求称作<strong>约束</strong>（其它语言有类似的概念，比如类型限制或trait限制或概念）。在这个情况，约束非常明显：类型必须有 <code>String() string</code> 方法。在别的情况中，可能没有那么明显。</p>
<p>我们不想从 Stringify 发生的地方衍生约束（在这个情况中，调用 String 方法的地方）。如果我们做了，对 Stringify 的一个小的改动可能会改变约束。那就意味着一个的改动可能影响很远的代码，调用这个函数的代码意外退出。对 Stringify 故意改变它的约束，并强制调用方改变是没有问题的。我们想要避免的是 Stringify 意外的改变了它的约束。</p>
<p>这意味着约束必须同时在调用者传入的类型参数和泛型函数中的代码中设置限制。调用者只能传满足约束的类型参数。泛型函数只能以约束允许的方式使用这些值。我们相信任何尝试在 Go 中定义泛型编程，这都是一条重要的规则：泛型代码只能使用它的类型参数知道实现了的操作。</p>
<h2 id="任意类型允许的操作"><a href="#任意类型允许的操作" class="headerlink" title="任意类型允许的操作"></a>任意类型允许的操作</h2><p>在我们讨论约束之前，我们简单的记住 <code>any</code> 约束是什么。如果一个泛型函数使用 <code>any</code> 约束，就像上面的 Print 函数一样，任意类型都允许。泛型函数中类型参数的值可以使用的操作就是那些被任意类型都允许的操作。在上面的例子中，Print 函数声明了一个变量 v 它的类型是 T，并且它把这个变量传给函数。</p>
<p>任意类型允许的操作是：</p>
<ul>
<li>声明这些类型的变量</li>
<li>把同类型的其它值你分配给这些值</li>
<li>把这些变量传给函数或者在函数返回它们</li>
<li>取这些变量的地址</li>
<li>转换或者分配这些类型的值给 interface{}</li>
<li>转换 T 类型的值到类型 T （允许但是没有用）</li>
<li>使用类型断言把一个 interace 类型的值转到这些类型</li>
<li>用在 type switch 中的 case</li>
<li>定义和使用这些类型的组合类型，比如这些类型的 slice</li>
<li>把这些类型传一些预定义的函数，比如 <code>new</code></li>
</ul>
<p>可能随着未来语言变化，可能增加其它的操作，但这不是现在可以预料的。</p>
<h3 id="定义约束"><a href="#定义约束" class="headerlink" title="定义约束"></a>定义约束</h3><p>Go 中已经有一种合约非常接近我们<strong>约束</strong>的需要：interface 类型。一个 interface 类型是一组方法。只有那些类型实现了同样的方法，它们的值才能分配给 interface 类型的值。interface 类型的值可以的事情，不是类型允许的操作，只是调用这些方法。</p>
<p>使用类型参数调用一个泛型函数跟赋值给 interface 类型非常相似：传入的类型参数必须实现类型参数的约束。写一个泛型函数就像使用 interface 类型的值：泛型代码只能使用被约束允许的操作（或者被<code>any</code> 类型允许的操作）。</p>
<p>所以，在这个设计中，约束就是简单的 interface 类型。满足约束就意味着实现 interface 类型。（为了定义非方法的操作约束，比如二进制操作，后面我们再重述这个）。</p>
<p>对于 Stringify 例子，我们需要一个 interface 类型：它有一个 String 方法，没有入参，返回一个 String 的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stringer 是一个类型约束，它要求类型参数有一个 String 方法并允许泛型函数调用 String.</span></span><br><span class="line"><span class="comment">// String 方法应该返回一个 string 代表的值。</span></span><br><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（跟这个讨论来没关系，但是这里定义了跟标准库 <code>fmt.Stringer</code> 一样的 interface 类型，真实的代码应该直接使用 <code>fmt.Stringer</code>）。</p>
<h2 id="any-约束"><a href="#any-约束" class="headerlink" title="any 约束"></a>any 约束</h2><p>现在我们知道约束就是简单的 interface 类型，我们可以解释 any 约束是什么意思。就像上面显示的那样，any 约束允许任何类型作为类型参数，并且只允许函数使用任意类型允许的操作。它的 interface 类型就是 <code>interface{}</code> （空接口）。所以我们像这样写 Print 的例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span>[<span class="title">T</span> <span class="title">interface</span></span>&#123;&#125;](s []T) &#123;</span><br><span class="line">    <span class="comment">// 跟上面一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，每次当你要写一个泛型函数，它不强制类型参数的约束的时候，必须每次都写 <code>interface{}</code>，这太无聊了。所以在这个设计中，我们建议约束 <code>any</code> 等价于 <code>interface{}</code>。这将是一个预定义的名字，在 universe block 中隐式声明。使用 any 用作类型参数约束以外的地方是无效的。</p>
<p>（注意：显然我们可以将 any 作为 interface{} 的别名，或者作为定义为 interface{} 的新类型。但是我们不希望这种关于泛型的设计导致非泛型代码的重大修改。添加 any 作为 interface{} 的通用名称可以而且应该单独讨论）</p>
<h2 id="使用约束"><a href="#使用约束" class="headerlink" title="使用约束"></a>使用约束</h2><p>对于泛型函数，约束中可以认为是类型参数的类型：元类型。就像上面显示的那样，约束出现在类型参数列表中，作为类型参数的元类型。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stringify 调用 s 中每个元素的 String 方法， 并且返回结果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stringify</span>[<span class="title">T</span> <span class="title">Stringer</span>]<span class="params">(s []T)</span> <span class="params">(ret []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        ret = <span class="built_in">append</span>(ret, v.String())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个情形中，类型参数 T 后面跟着对它的约束。</p>
<h2 id="多个类型参数"><a href="#多个类型参数" class="headerlink" title="多个类型参数"></a>多个类型参数</h2><p>虽然 Stringify 的例子只用了一个类型参数，函数也可以有多个类型参数。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Print2 有两个类型参数，和两个非类型参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print2</span>[<span class="title">T1</span>, <span class="title">T2</span> <span class="title">any</span>]<span class="params">(s1 []T1, s2 []T2)</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><br>跟这个相比<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Print2Same 有一个类型参数和两个非类型参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print2Same</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(s1 []T, s2 []T)</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p>Print2 中，s1 和 s2 可能是不同类型的 slice。在 Print2Same 中，s1 和 s2 必须是同一个类型的 slice。</p>
<p>就像每个普通参数都有自己的类型，每个类型参数也有自己的约束。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stringer 是一个需要 String 方法的约束。</span></span><br><span class="line"><span class="comment">// String 方法需要返回一个 string。</span></span><br><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Plusser 是一个需要 Plus 方法的约束。</span></span><br><span class="line"><span class="comment">// Plus 方法期望对内部的字符串增加一个参数，然后返回结果。</span></span><br><span class="line"><span class="keyword">type</span> Plusser <span class="keyword">interface</span> &#123;</span><br><span class="line">    Plus(<span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcatTo 接收一个slice, 其中每个元素都有一个 String 方法，和一个slice, 其中每个元素都有一个 Plus 方法。</span></span><br><span class="line"><span class="comment">// 这些 slice 的元素数量比須相同。这将把 s 中的每个元素转成一个字符串，把它传给 p 中相应元素的 Plus 方法，</span></span><br><span class="line"><span class="comment">// 并且返回一个 slice, 其中包含结果 string.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcatTo</span>[<span class="title">S</span> <span class="title">Stringer</span>, <span class="title">P</span> <span class="title">Plusser</span>]<span class="params">(s []S, p []P)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    r := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(s))</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        r[i] = p[i].Plus(v.String())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个约束可以用到多个类型参数，就像一个类型参数可以用到多个非类型参数上。约束单独应用到每个类型参数上。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stringify2 将两个不类型的 slice 转成 string, 并且返回所有 string 连接的结果。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stringify2</span>[<span class="title">T1</span>, <span class="title">T2</span> <span class="title">Stringer</span>]<span class="params">(s1 []T1, s2 []T2)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    r := <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> _, v1 := <span class="keyword">range</span> s1 &#123;</span><br><span class="line">        r += v1.String()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, v2 := <span class="keyword">range</span> s2 &#123;</span><br><span class="line">        r += v2.String()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h2><p>除了泛型函数，我们还想要泛型类型。我们建议类型可以被扩展到接受类型参数。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vector 是一个元素可以为任意类型的 slice.</span></span><br><span class="line"><span class="keyword">type</span> Vector[T any] []T</span><br></pre></td></tr></table></figure></p>
<p>类型的类型参数就像函数的类型参数一样。</p>
<p>在类型定义中，类型参数可以像别的类型一样使用。</p>
<p>为了使用泛型类型，你必须提供类型参数。这叫做实例化。类型参数就像以前一样出现在方括号中。当我们通过为类型参数提供类型参数来实例化一个类型时，我们会产生一个类型，其中在类型定义中的类型参数的每次使用，都会被相应类型实参替换。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v 是一个整形值的 Vector</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 这就相当于假装 "Vector[int]" 是一个有效的标识符，</span></span><br><span class="line"><span class="comment">// 并且写做</span></span><br><span class="line"><span class="comment">//      type "Vector[int]" []int</span></span><br><span class="line"><span class="comment">//      var v "Vector[int]"</span></span><br><span class="line"><span class="comment">// 所有 Vector[int] 使用的地方都指向同一个 "Vector[int]" type.</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">var</span> v Vector[<span class="keyword">int</span>]</span><br></pre></td></tr></table></figure>
<p>泛型类型也可以有方法。方法的接收者类型必须声明同样数量的类型参数, 跟声明在接收者类型定义一样。它们的声明没有约束。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Push 增加一个值到一个 Vector 的末尾</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vector[T])</span> <span class="title">Push</span><span class="params">(x T)</span></span> &#123; *v = <span class="built_in">append</span>(*v, x) &#125;</span><br></pre></td></tr></table></figure>
<p>在方法声明中列出的类型参数，不需要拥有跟在类型定义中的类型参数一样的名字。特别地，如果它们没有被方法使用，它们可以是 <code>_</code>。</p>
<p>在一个类型通常可以引用自身的情况下，泛型类型可以引用自身。但是当它这样做时，类型参数必须是类型参数，以相同的顺序列出。此限制可以防止类型参数实例化的无限递归。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List 是一个链表，其值是类型 T</span></span><br><span class="line"><span class="keyword">type</span> List[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    next *List[T]  <span class="comment">// 这个引用到 List[T] 是允许的</span></span><br><span class="line">    val T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个类型是无效的</span></span><br><span class="line"><span class="keyword">type</span> P[T1, T2 any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    F *P[T2, T1] <span class="comment">// 无效的； 必须是 [T1, T2]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个限制对直接引用和间接引用都有效。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListHead 是一个链表的头</span></span><br><span class="line"><span class="keyword">type</span> ListHead[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    head *ListElement[T]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListElement 是有头链表的一个元素。</span></span><br><span class="line"><span class="comment">// 每个元素指向头</span></span><br><span class="line"><span class="keyword">type</span> ListElement[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    next *ListElement[T]</span><br><span class="line">    val T</span><br><span class="line">    <span class="comment">// 这里使用 ListHead[T] 是可以的。</span></span><br><span class="line">    <span class="comment">// ListHead[T] 引用 ListElement[T] 引用 ListHead[T]。</span></span><br><span class="line">    <span class="comment">// 使用 ListHead[int] 就不可以，因为 ListHead[T] 可能有一个间接引用到 ListHead[int].</span></span><br><span class="line">    head *ListHead[T]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(注意：随着对人首怎么写代码越来越了解，可能会放松这个规则以允许一些使用不同类型参数的case)</p>
<p>泛型类型的类型参数可能拥有不是any 的约束。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StringableVector 是一个一些类型的 slice，这里的类型必须有 String 方法。</span></span><br><span class="line"><span class="keyword">type</span> StringableVector[T Stringer] []T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StringableVector[T])</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sb strings.Builder</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">            sb.WriteString(<span class="string">", "</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里调用 v.String() 是可以的，因为 v 的类型是 T，T有一个约束是 Stringer</span></span><br><span class="line">        sb.WriteString(v.String())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法可能不带另外的类型参数"><a href="#方法可能不带另外的类型参数" class="headerlink" title="方法可能不带另外的类型参数"></a>方法可能不带另外的类型参数</h2><p>尽管泛型类型的方法可能使用类型参数，方法可能没有另外的类型参数。这里给方法增加类型参数可能是有用的，人们不得不写一个适当参数化的顶级函数。</p>
<p><a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#No-parameterized-methods" target="_blank" rel="noopener">这里有更多的讨论</a></p>
<p>（未完，待续。。。）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://fantasyczl.com/2022/04/05/20220405-go-generic-proposal/" data-id="cl1s1y8mx0003yv4i0jmmaraq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go/" rel="tag">Go</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2021/05/22/20210522-http-code-502-vs-504/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">HTTP 状态码 502 与 504 的区别</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Go/" rel="tag">Go</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Laravel/" rel="tag">Laravel</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NetWork/" rel="tag">NetWork</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nginx/" rel="tag">Nginx</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PHP/" rel="tag">PHP</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Process/" rel="tag">Process</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/" rel="tag">Shell</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/" rel="tag">TCP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Thread/" rel="tag">Thread</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/" rel="tag">vim</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/Git/" style="font-size: 13.33px;">Git</a> <a href="/tags/Go/" style="font-size: 16.67px;">Go</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Laravel/" style="font-size: 10px;">Laravel</a> <a href="/tags/Linux/" style="font-size: 20px;">Linux</a> <a href="/tags/NetWork/" style="font-size: 10px;">NetWork</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/PHP/" style="font-size: 16.67px;">PHP</a> <a href="/tags/Process/" style="font-size: 10px;">Process</a> <a href="/tags/Python/" style="font-size: 13.33px;">Python</a> <a href="/tags/Shell/" style="font-size: 13.33px;">Shell</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/Thread/" style="font-size: 10px;">Thread</a> <a href="/tags/vim/" style="font-size: 13.33px;">vim</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">八月 2015</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/04/05/20220405-go-generic-proposal/">Golang 泛型提案学习</a>
          </li>
        
          <li>
            <a href="/2021/05/22/20210522-http-code-502-vs-504/">HTTP 状态码 502 与 504 的区别</a>
          </li>
        
          <li>
            <a href="/2021/03/28/20210328-golang-cpu-too-high/">一个Go服务占用CPU太高的优化过程</a>
          </li>
        
          <li>
            <a href="/2021/02/18/20210218-golang-optimization/">Go 优化Tips</a>
          </li>
        
          <li>
            <a href="/2020/08/27/20200827-php-subpattern/">PHP 中多个 Subpattern 匹配问题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 fantasyczl<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


  </div>
</body>
</html>